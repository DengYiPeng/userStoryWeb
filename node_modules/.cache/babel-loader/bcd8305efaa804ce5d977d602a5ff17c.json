{"ast":null,"code":"import _extends from 'babel-runtime/helpers/extends';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { getTrackCSS, getTrackLeft, getTrackAnimateCSS } from './trackHelper';\nvar helpers = {\n  initialize: function initialize(props) {\n    var _this = this;\n\n    var slickList = ReactDOM.findDOMNode(this.list);\n    var slideCount = React.Children.count(props.children);\n    var listWidth = this.getWidth(slickList);\n    var trackWidth = this.getWidth(ReactDOM.findDOMNode(this.track));\n    var slideWidth = void 0;\n\n    if (!props.vertical) {\n      var centerPaddingAdj = props.centerMode && parseInt(props.centerPadding) * 2;\n      slideWidth = (listWidth - centerPaddingAdj) / props.slidesToShow;\n    } else {\n      slideWidth = listWidth;\n    }\n\n    var slideHeight = this.getHeight(slickList.querySelector('[data-index=\"0\"]'));\n    var listHeight = slideHeight * props.slidesToShow;\n    var slidesToShow = props.slidesToShow || 1;\n    var currentSlide = props.rtl ? slideCount - 1 - (slidesToShow - 1) - props.defaultActiveIndex : props.defaultActiveIndex;\n    this.setState({\n      slideCount: slideCount,\n      slideWidth: slideWidth,\n      listWidth: listWidth,\n      trackWidth: trackWidth,\n      currentSlide: currentSlide,\n      slideHeight: slideHeight,\n      listHeight: listHeight\n    }, function () {\n      var targetLeft = getTrackLeft(_extends({\n        slideIndex: _this.state.currentSlide,\n        trackRef: _this.track\n      }, props, _this.state)); // getCSS function needs previously set state\n\n      var trackStyle = getTrackCSS(_extends({\n        left: targetLeft\n      }, props, _this.state));\n\n      _this.setState({\n        trackStyle: trackStyle\n      });\n\n      _this.autoPlay(); // once we're set up, trigger the initial autoplay.\n\n    });\n  },\n  update: function update(props) {\n    this.initialize(props);\n  },\n  getWidth: function getWidth(elem) {\n    return elem.getBoundingClientRect().width || elem.offsetWidth;\n  },\n  getHeight: function getHeight(elem) {\n    return elem.getBoundingClientRect().height || elem.offsetHeight;\n  },\n  adaptHeight: function adaptHeight() {\n    if (this.props.adaptiveHeight) {\n      var selector = '[data-index=\"' + this.state.currentSlide + '\"]';\n\n      if (this.list) {\n        var slickList = ReactDOM.findDOMNode(this.list);\n        var listHeight = slickList.querySelector(selector).offsetHeight;\n        slickList.style.height = listHeight + 'px';\n      }\n    }\n  },\n  canGoNext: function canGoNext(opts) {\n    var canGo = true;\n\n    if (!opts.infinite) {\n      if (opts.centerMode) {\n        if (opts.currentSlide >= opts.slideCount - 1) {\n          canGo = false;\n        }\n      } else if (opts.slideCount <= opts.slidesToShow || opts.currentSlide >= opts.slideCount - opts.slidesToShow) {\n        // check if all slides are shown in slider\n        canGo = false;\n      }\n    }\n\n    return canGo;\n  },\n  slideHandler: function slideHandler(index) {\n    var _this2 = this;\n\n    var rtl = this.props.rtl; // Functionality of animateSlide and postSlide is merged into this function\n\n    var targetSlide = void 0,\n        currentSlide = void 0;\n    var callback = void 0;\n\n    if (this.props.waitForAnimate && this.state.animating) {\n      return;\n    }\n\n    if (this.props.animation === 'fade') {\n      currentSlide = this.state.currentSlide; // don't change slide if it's not infinite and current slide is the first or last slide'\n\n      if (this.props.infinite === false && (index < 0 || index >= this.state.slideCount)) {\n        return;\n      } //  Shifting targetSlide back into the range\n\n\n      if (index < 0) {\n        targetSlide = index + this.state.slideCount;\n      } else if (index >= this.state.slideCount) {\n        targetSlide = index - this.state.slideCount;\n      } else {\n        targetSlide = index;\n      }\n\n      if (this.props.lazyLoad && this.state.lazyLoadedList.indexOf(targetSlide) < 0) {\n        this.setState({\n          lazyLoadedList: this.state.lazyLoadedList.concat(targetSlide)\n        });\n      }\n\n      callback = function callback() {\n        _this2.setState({\n          animating: false\n        });\n\n        _this2.props.onChange(targetSlide);\n\n        delete _this2.animationEndCallback;\n      };\n\n      this.setState({\n        animating: true,\n        currentSlide: targetSlide\n      }, function () {\n        this.animationEndCallback = setTimeout(callback, this.props.speed + 20);\n      });\n      this.autoPlay();\n      return;\n    }\n\n    targetSlide = index;\n\n    if (rtl) {\n      if (targetSlide < 0) {\n        if (this.props.infinite === false) {\n          currentSlide = 0;\n        } else if (this.state.slideCount % this.props.slidesToScroll !== 0) {\n          if (targetSlide + this.props.slidesToScroll <= 0) {\n            currentSlide = this.state.slideCount + targetSlide;\n            targetSlide = this.state.slideCount - this.props.slidesToScroll;\n          } else {\n            currentSlide = targetSlide = 0;\n          }\n        } else {\n          // this.state.slideCount % this.props.slidesToScroll\n          currentSlide = this.state.slideCount + targetSlide;\n        }\n      } else if (targetSlide >= this.state.slideCount) {\n        if (this.props.infinite === false) {\n          currentSlide = this.state.slideCount - this.props.slidesToShow;\n        } else if (this.state.slideCount % this.props.slidesToScroll !== 0) {\n          currentSlide = 0;\n        } else {\n          currentSlide = targetSlide - this.state.slideCount;\n        }\n      } else {\n        currentSlide = targetSlide;\n      }\n    } else if (targetSlide < 0) {\n      if (this.props.infinite === false) {\n        currentSlide = 0;\n      } else if (this.state.slideCount % this.props.slidesToScroll !== 0) {\n        currentSlide = this.state.slideCount - this.state.slideCount % this.props.slidesToScroll;\n      } else {\n        currentSlide = this.state.slideCount + targetSlide;\n      }\n    } else if (targetSlide >= this.state.slideCount) {\n      if (this.props.infinite === false) {\n        currentSlide = this.state.slideCount - this.props.slidesToShow;\n      } else if (this.state.slideCount % this.props.slidesToScroll !== 0) {\n        currentSlide = 0;\n      } else {\n        currentSlide = targetSlide - this.state.slideCount;\n      }\n    } else {\n      currentSlide = targetSlide;\n    }\n\n    var targetLeft = getTrackLeft(_extends({\n      slideIndex: targetSlide,\n      trackRef: this.track\n    }, this.props, this.state));\n    var currentLeft = getTrackLeft(_extends({\n      slideIndex: currentSlide,\n      trackRef: this.track\n    }, this.props, this.state));\n\n    if (this.props.infinite === false) {\n      targetLeft = currentLeft;\n    }\n\n    if (this.props.lazyLoad) {\n      var loaded = true;\n      var slidesToLoad = [];\n      var sliderIndex = targetSlide < 0 ? this.state.slideCount + targetSlide : currentSlide;\n\n      for (var i = sliderIndex; i < sliderIndex + this.props.slidesToShow; i++) {\n        var k = i;\n\n        if (rtl) {\n          k = i >= this.state.slideCount ? this.state.slideCount * 2 - i - 1 : this.state.slideCount - i - 1;\n        }\n\n        loaded = loaded && this.state.lazyLoadedList.indexOf(k) >= 0;\n\n        if (!loaded) {\n          slidesToLoad.push(k);\n        }\n      }\n\n      if (!loaded) {\n        this.setState({\n          lazyLoadedList: this.state.lazyLoadedList.concat(slidesToLoad)\n        });\n      }\n    } // Slide Transition happens here.\n    // animated transition happens to target Slide and\n    // non - animated transition happens to current Slide\n    // If CSS transitions are false, directly go the current slide.\n\n    /* istanbul ignore if */\n\n\n    if (this.props.useCSS === false) {\n      this.setState({\n        currentSlide: currentSlide,\n        trackStyle: getTrackCSS(_extends({\n          left: currentLeft\n        }, this.props, this.state))\n      }, function () {\n        _this2.props.onChange(currentSlide);\n      });\n    } else {\n      var nextStateChanges = {\n        animating: false,\n        currentSlide: currentSlide,\n        trackStyle: getTrackCSS(_extends({\n          left: currentLeft\n        }, this.props, this.state)),\n        swipeLeft: null\n      };\n\n      callback = function callback() {\n        _this2.setState(nextStateChanges);\n\n        _this2.props.onChange(currentSlide);\n\n        delete _this2.animationEndCallback;\n      };\n\n      this.setState({\n        animating: true,\n        currentSlide: currentSlide,\n        trackStyle: getTrackAnimateCSS(_extends({\n          left: targetLeft\n        }, this.props, this.state))\n      }, function () {\n        this.animationEndCallback = setTimeout(callback, this.props.speed + 20);\n      });\n    }\n\n    this.autoPlay();\n  },\n  // 鼠标悬浮在 arrow 上时作出动画反馈\n  arrowHoverHandler: function arrowHoverHandler(msg) {\n    var offset = 30; // slide 的位置偏移量\n\n    var targetLeft = getTrackLeft(_extends({\n      slideIndex: this.state.currentSlide,\n      trackRef: this.track\n    }, this.props, this.state));\n    var left = void 0;\n    /* istanbul ignore next */\n\n    if (msg === 'next') {\n      left = targetLeft - offset;\n    } else if (msg === 'prev') {\n      left = targetLeft + offset;\n    } else {\n      left = targetLeft;\n    }\n\n    this.setState({\n      trackStyle: getTrackAnimateCSS(_extends({\n        left: left\n      }, this.props, this.state))\n    });\n  },\n  swipeDirection: function swipeDirection(touchObject) {\n    /* istanbul ignore next */\n    var swipeAngle = void 0;\n    /* istanbul ignore next */\n\n    var xDist = touchObject.startX - touchObject.curX;\n    /* istanbul ignore next */\n\n    var yDist = touchObject.startY - touchObject.curY;\n    /* istanbul ignore next */\n\n    var r = Math.atan2(yDist, xDist);\n    /* istanbul ignore next */\n\n    swipeAngle = Math.round(r * 180 / Math.PI);\n    /* istanbul ignore next */\n\n    if (swipeAngle < 0) {\n      swipeAngle = 360 - Math.abs(swipeAngle);\n    }\n    /* istanbul ignore next */\n\n\n    if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {\n      return this.props.rtl === false ? 'left' : 'right';\n    }\n    /* istanbul ignore next */\n\n\n    if (swipeAngle >= 135 && swipeAngle <= 225) {\n      return this.props.rtl === false ? 'right' : 'left';\n    }\n    /* istanbul ignore next */\n\n\n    if (this.props.verticalSwiping === true) {\n      if (swipeAngle >= 35 && swipeAngle <= 135) {\n        return 'down';\n      } else {\n        return 'up';\n      }\n    }\n    /* istanbul ignore next */\n\n\n    return 'vertical';\n  },\n  play: function play() {\n    var nextIndex = void 0;\n\n    if (!this.hasMounted) {\n      /* istanbul ignore next */\n      return false;\n    }\n\n    if (this.props.rtl) {\n      nextIndex = this.state.currentSlide - this.props.slidesToScroll;\n    } else if (this.canGoNext(_extends({}, this.props, this.state))) {\n      nextIndex = this.state.currentSlide + this.props.slidesToScroll;\n    } else {\n      return false;\n    }\n\n    this.slideHandler(nextIndex);\n  },\n  autoPlay: function autoPlay() {\n    if (this.state.autoPlayTimer) {\n      clearTimeout(this.state.autoPlayTimer);\n    }\n\n    if (this.props.autoplay) {\n      this.setState({\n        autoPlayTimer: setTimeout(this.play.bind(this), this.props.autoplaySpeed)\n      });\n    }\n  },\n  pause: function pause() {\n    /* istanbul ignore next */\n    if (this.state.autoPlayTimer) {\n      clearTimeout(this.state.autoPlayTimer);\n      this.setState({\n        autoPlayTimer: null\n      });\n    }\n  }\n};\nexport default helpers;","map":null,"metadata":{},"sourceType":"module"}