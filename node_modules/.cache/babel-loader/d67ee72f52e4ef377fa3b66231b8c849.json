{"ast":null,"code":"import _extends from 'babel-runtime/helpers/extends';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport ReactDOM from 'react-dom';\nimport { log, func } from '../util';\nimport Validate from '../validate';\nimport { getValueFromEvent, getErrorStrs, getParams, setIn, getIn, mapValidateRules } from './utils';\nvar initMeta = {\n  state: '',\n  valueName: 'value',\n  trigger: 'onChange'\n};\n\nvar Field = function () {\n  function Field(com) {\n    var _this = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Field);\n\n    if (!com) {\n      log.warning('`this` is missing in `Field`, you should use like `new Field(this)`');\n    }\n\n    this.com = com;\n    this.fieldsMeta = {};\n    this.cachedBind = {};\n    this.instance = {};\n    this.options = _extends({\n      parseName: false,\n      forceUpdate: false,\n      scrollToFirstError: true,\n      first: false,\n      onChange: func.noop,\n      autoUnmount: true\n    }, options);\n    ['init', 'getValue', 'getValues', 'setValue', 'setValues', 'getError', 'setError', 'setErrors', 'validate', 'getState', 'reset', 'resetToDefault', 'remove'].forEach(function (m) {\n      _this[m] = _this[m].bind(_this);\n    });\n\n    if (options.values) {\n      this.setValues(options.values, false);\n    }\n  }\n\n  Field.prototype.setOptions = function setOptions(options) {\n    _extends(this.options, options);\n  };\n  /**\n   * Control Component\n   * @param {String} name\n   * @param {Object} fieldOption\n   * @returns {Object} {value, onChange}\n   */\n\n\n  Field.prototype.init = function init(name) {\n    var _inputProps,\n        _this2 = this;\n\n    var fieldOption = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var rprops = arguments[2];\n    var initValue = fieldOption.initValue,\n        _fieldOption$valueNam = fieldOption.valueName,\n        valueName = _fieldOption$valueNam === undefined ? 'value' : _fieldOption$valueNam,\n        _fieldOption$trigger = fieldOption.trigger,\n        trigger = _fieldOption$trigger === undefined ? 'onChange' : _fieldOption$trigger,\n        _fieldOption$rules = fieldOption.rules,\n        rules = _fieldOption$rules === undefined ? [] : _fieldOption$rules,\n        _fieldOption$props = fieldOption.props,\n        props = _fieldOption$props === undefined ? {} : _fieldOption$props,\n        _fieldOption$getValue = fieldOption.getValueFromEvent,\n        getValueFromEvent = _fieldOption$getValue === undefined ? null : _fieldOption$getValue;\n\n    var originalProps = _extends({}, props, rprops);\n\n    var defaultValueName = 'default' + valueName[0].toUpperCase() + valueName.slice(1);\n\n    var field = this._getInitMeta(name);\n\n    var defaultValue = typeof initValue !== 'undefined' ? initValue : originalProps[defaultValueName];\n\n    _extends(field, {\n      valueName: valueName,\n      initValue: defaultValue,\n      disabled: 'disabled' in originalProps ? originalProps.disabled : false,\n      getValueFromEvent: getValueFromEvent,\n      rules: Array.isArray(rules) ? rules : [rules],\n      ref: originalProps.ref\n    }); // Control Component\n\n\n    if (valueName in originalProps) {\n      field.value = originalProps[valueName];\n    }\n\n    if (!('value' in field)) {\n      field.value = defaultValue;\n    } // Component props\n\n\n    var inputProps = (_inputProps = {\n      'data-meta': 'Field',\n      id: name,\n      ref: this._getCacheBind(name, name + '__ref', this._saveRef)\n    }, _inputProps[valueName] = field.value, _inputProps); // trigger map\n\n    var rulesMap = mapValidateRules(field.rules, trigger); // validate hook\n\n    var _loop = function _loop(action) {\n      if (action === trigger) {\n        return 'continue';\n      }\n\n      var actionRule = rulesMap[action];\n\n      inputProps[action] = function () {\n        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        _this2._validate(name, actionRule, action);\n\n        _this2._callPropsEvent.apply(_this2, [action, originalProps].concat(args));\n\n        _this2._reRender();\n      };\n    };\n\n    for (var action in rulesMap) {\n      var _ret = _loop(action);\n\n      if (_ret === 'continue') continue;\n    } // onChange hack\n\n\n    inputProps[trigger] = function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this2._callOnChange.apply(_this2, [name, rulesMap[trigger], trigger].concat(args));\n\n      _this2._callPropsEvent.apply(_this2, [trigger, originalProps].concat(args));\n\n      _this2.options.onChange(name, field.value);\n\n      _this2._reRender();\n    };\n\n    delete originalProps[defaultValueName];\n    return _extends({}, originalProps, inputProps);\n  };\n  /**\n   * event on props\n   * props.onChange props.onBlur\n   */\n\n\n  Field.prototype._callPropsEvent = function _callPropsEvent(action, props) {\n    for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      args[_key3 - 2] = arguments[_key3];\n    }\n\n    action in props && typeof props[action] === 'function' && props[action].apply(props, args);\n  };\n\n  Field.prototype._getInitMeta = function _getInitMeta(name) {\n    if (!(name in this.fieldsMeta)) {\n      this.fieldsMeta[name] = _extends({}, initMeta);\n    }\n\n    return this.fieldsMeta[name];\n  };\n\n  Field.prototype._callOnChange = function _callOnChange(name, rule, trigger) {\n    for (var _len4 = arguments.length, others = Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {\n      others[_key4 - 3] = arguments[_key4];\n    }\n\n    var e = others[0];\n\n    var field = this._get(name);\n\n    if (!field) {\n      return;\n    }\n\n    field.value = field.getValueFromEvent ? field.getValueFromEvent.apply(this, others) : getValueFromEvent(e);\n\n    this._resetError(name);\n\n    rule && this._validate(name, rule, trigger);\n  };\n  /**\n   * ref must always be the same function, or if not it will be triggerd every time.\n   * @param {String} name name of component\n   * @param {String} action key to find ref\n   * @param {Function} fn saveRef\n   */\n\n\n  Field.prototype._getCacheBind = function _getCacheBind(name, action, fn) {\n    var cache = this.cachedBind[name] = this.cachedBind[name] || {};\n\n    if (!cache[action]) {\n      cache[action] = fn.bind(this, name);\n    }\n\n    return cache[action];\n  };\n\n  Field.prototype._setCache = function _setCache(name, action, hander) {\n    var cache = this.cachedBind[name] = this.cachedBind[name] || {};\n    cache[action] = hander;\n  };\n\n  Field.prototype._getCache = function _getCache(name, action) {\n    var cache = this.cachedBind[name] || {};\n    return cache[action];\n  };\n  /**\n   * saveRef is async function. it will be called after render\n   * @param {String} name name of component\n   * @param {Function} component ref\n   */\n\n\n  Field.prototype._saveRef = function _saveRef(name, component) {\n    var key = name + '_field';\n    var autoUnmount = this.options.autoUnmount;\n\n    if (!component && autoUnmount) {\n      // component with same name(eg: type? <A name=\"n\"/>:<B name=\"n\"/>)\n      // while type change to true B will render before A unmount.\n      var cache = this.fieldsMeta[name];\n\n      this._setCache(name, key, cache); // after destroy, delete data\n\n\n      delete this.fieldsMeta[name];\n      delete this.instance[name];\n      return;\n    } // after _saveRef(name, null) and before rerender. (eg: same name but different compoent may be here)\n\n\n    if (autoUnmount && !this.fieldsMeta[name]) {\n      this.fieldsMeta[name] = this._getCache(name, key);\n    } // only one time here\n\n\n    var field = this._get(name);\n\n    if (field) {\n      var ref = field.ref;\n\n      if (ref) {\n        if (typeof ref === 'string') {\n          throw new Error('can not set string ref for ' + name);\n        }\n\n        ref(component);\n      }\n\n      this.instance[name] = component;\n    }\n  };\n  /**\n   * validate one Component\n   * @param {String} name name of Component\n   * @param {Array} rule\n   * @param {String} trigger onChange/onBlur/onItemClick/...\n   */\n\n\n  Field.prototype._validate = function _validate(name, rule, trigger) {\n    var _ref,\n        _validate$validate,\n        _this3 = this;\n\n    var field = this._get(name);\n\n    var value = field.value;\n    field.state = 'loading';\n\n    var validate = this._getCache(name, trigger);\n\n    validate && validate.abort();\n    validate = new Validate((_ref = {}, _ref[name] = rule, _ref));\n\n    this._setCache(name, trigger, validate);\n\n    validate.validate((_validate$validate = {}, _validate$validate[name] = value, _validate$validate), function (errors) {\n      if (errors && errors.length) {\n        field.errors = getErrorStrs(errors);\n        field.state = 'error';\n      } else {\n        field.errors = [];\n        field.state = 'success';\n      }\n\n      _this3._reRender();\n    });\n  };\n\n  Field.prototype.getValue = function getValue(name) {\n    var field = this._get(name);\n\n    if (field && 'value' in field) {\n      return field.value;\n    }\n\n    return undefined;\n  };\n  /**\n   * 1. get values by names.\n   * 2. ignore disabled value.\n   * @param {Array} names\n   */\n\n\n  Field.prototype.getValues = function getValues(names) {\n    var _this4 = this;\n\n    var fields = names || this.getNames();\n    var allValues = {};\n    fields.forEach(function (f) {\n      if (f.disabled) {\n        return;\n      }\n\n      if (!_this4.options.parseName) {\n        allValues[f] = _this4.getValue(f);\n      } else {\n        allValues = setIn(allValues, f, _this4.getValue(f));\n      }\n    });\n    return allValues;\n  };\n\n  Field.prototype.setValue = function setValue(name, value) {\n    var reRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    if (name in this.fieldsMeta) {\n      this.fieldsMeta[name].value = value;\n    } else {\n      // if not exist, then new one\n      this.fieldsMeta[name] = {\n        value: value\n      };\n    }\n\n    reRender && this._reRender();\n  };\n\n  Field.prototype.setValues = function setValues() {\n    var _this5 = this;\n\n    var fieldsValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var reRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (!this.options.parseName) {\n      Object.keys(fieldsValue).forEach(function (name) {\n        _this5.setValue(name, fieldsValue[name], false);\n      });\n    } else {\n      var fields = this.getNames();\n      fields.forEach(function (name) {\n        var value = getIn(fieldsValue, name);\n\n        if (value !== undefined) {\n          _this5.setValue(name, value, false);\n        }\n      });\n    }\n\n    reRender && this._reRender();\n  };\n\n  Field.prototype.setError = function setError(name, errors) {\n    var err = Array.isArray(errors) ? errors : errors ? [errors] : [];\n\n    if (name in this.fieldsMeta) {\n      this.fieldsMeta[name].errors = err;\n    } else {\n      this.fieldsMeta[name] = {\n        errors: err\n      };\n    }\n\n    if (this.fieldsMeta[name].errors && this.fieldsMeta[name].errors.length > 0) {\n      this.fieldsMeta[name].state = 'error';\n    } else {\n      this.fieldsMeta[name].state = '';\n    }\n\n    this._reRender();\n  };\n\n  Field.prototype.setErrors = function setErrors() {\n    var _this6 = this;\n\n    var fieldsErrors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    Object.keys(fieldsErrors).forEach(function (name) {\n      _this6.setError(name, fieldsErrors[name]);\n    });\n  };\n\n  Field.prototype.getError = function getError(name) {\n    var field = this._get(name);\n\n    if (field && field.errors && field.errors.length) {\n      return field.errors;\n    }\n\n    return null;\n  };\n\n  Field.prototype.getErrors = function getErrors(names) {\n    var _this7 = this;\n\n    var fields = names || this.getNames();\n    var allErrors = {};\n    fields.forEach(function (f) {\n      allErrors[f] = _this7.getError(f);\n    });\n    return allErrors;\n  };\n\n  Field.prototype.getState = function getState(name) {\n    var field = this._get(name);\n\n    if (field && field.state) {\n      return field.state;\n    }\n\n    return '';\n  };\n  /**\n   * validate by trigger\n   * @param {Array} ns names\n   * @param {Function} cb callback after validate\n   */\n\n\n  Field.prototype.validate = function validate(ns, cb) {\n    var _this8 = this;\n\n    var _getParams = getParams(ns, cb),\n        names = _getParams.names,\n        callback = _getParams.callback;\n\n    var fieldNames = names || this.getNames();\n    var descriptor = {};\n    var values = {};\n    var hasRule = false;\n\n    for (var i = 0; i < fieldNames.length; i++) {\n      var name = fieldNames[i];\n\n      var field = this._get(name);\n\n      if (!field) {\n        continue;\n      }\n\n      if (field.rules && field.rules.length) {\n        descriptor[name] = field.rules;\n        values[name] = this.getValue(name);\n        hasRule = true; // clear error\n\n        field.errors = [];\n        field.state = '';\n      }\n    }\n\n    if (!hasRule) {\n      callback && callback(null, this.getValues(fieldNames));\n      return;\n    }\n\n    var validate = new Validate(descriptor, {\n      first: this.options.first\n    });\n    validate.validate(values, function (errors) {\n      var errorsGroup = null;\n\n      if (errors && errors.length) {\n        errorsGroup = {};\n        errors.forEach(function (e) {\n          var fieldName = e.field;\n\n          if (!errorsGroup[fieldName]) {\n            errorsGroup[fieldName] = {\n              errors: []\n            };\n          }\n\n          var fieldErrors = errorsGroup[fieldName].errors;\n          fieldErrors.push(e.message);\n        });\n      }\n\n      if (errorsGroup) {\n        // update error in every Field\n        Object.keys(errorsGroup).forEach(function (i) {\n          var field = _this8._get(i);\n\n          field.errors = errorsGroup[i].errors;\n          field.state = 'error';\n        });\n      } // update to success which has no error\n\n\n      for (var _i = 0; _i < fieldNames.length; _i++) {\n        var _name = fieldNames[_i];\n\n        var _field = _this8._get(_name);\n\n        if (_field.rules && !(errorsGroup && _name in errorsGroup)) {\n          _field.state = 'success';\n        }\n      }\n\n      callback && callback(errorsGroup, _this8.getValues(fieldNames));\n\n      _this8._reRender();\n\n      if (errorsGroup && _this8.options.scrollToFirstError) {\n        var firstNode = void 0;\n        var firstTop = void 0;\n\n        for (var _i2 in errorsGroup) {\n          if (errorsGroup.hasOwnProperty(_i2)) {\n            var instance = _this8.instance[_i2];\n            var node = ReactDOM.findDOMNode(instance);\n\n            if (!node) {\n              return;\n            }\n\n            var top = node.offsetTop;\n\n            if (firstTop === undefined || firstTop > top) {\n              firstTop = top;\n              firstNode = node;\n            }\n          }\n        }\n\n        if (firstNode) {\n          if (typeof _this8.options.scrollToFirstError === 'number' && window && typeof window.scrollTo === 'function') {\n            var offsetLeft = document && document.body && document.body.offsetLeft ? document.body.offsetLeft : 0;\n            window.scrollTo(offsetLeft, firstTop + _this8.options.scrollToFirstError);\n          } else if (firstNode.scrollIntoViewIfNeeded) {\n            firstNode.scrollIntoViewIfNeeded(true);\n          }\n        }\n      }\n    });\n  };\n\n  Field.prototype._reset = function _reset(ns, backToDefault) {\n    var _this9 = this;\n\n    if (typeof ns === 'string') {\n      ns = [ns];\n    }\n\n    var changed = false;\n    var names = ns || Object.keys(this.fieldsMeta);\n    names.forEach(function (name) {\n      var field = _this9._get(name);\n\n      _this9.getValue(name);\n\n      if (field) {\n        changed = true;\n        field.value = backToDefault ? field.initValue : undefined;\n        field.state = '';\n        delete field.errors;\n        delete field.rules;\n        delete field.rulesMap;\n      }\n    });\n\n    if (changed) {\n      this._reRender();\n    }\n  };\n\n  Field.prototype.reset = function reset(ns) {\n    var backToDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (ns === true) {\n      log.deprecated('reset(true)', 'resetToDefault()', 'Field');\n      this.resetToDefault();\n    } else if (backToDefault === true) {\n      log.deprecated('reset(ns,true)', 'resetToDefault(ns)', 'Field');\n      this.resetToDefault(ns);\n    } else {\n      this._reset(ns, false);\n    }\n  };\n\n  Field.prototype.resetToDefault = function resetToDefault(ns) {\n    this._reset(ns, true);\n  }; // deprecated. TODO: remove in 2.0 version\n\n\n  Field.prototype.isValidating = function isValidating(name) {\n    log.deprecated('isValidating', 'getState', 'Field');\n    return this.getState(name) === 'loading';\n  };\n\n  Field.prototype.getNames = function getNames() {\n    var fieldsMeta = this.fieldsMeta;\n    return fieldsMeta ? Object.keys(fieldsMeta).filter(function () {\n      return true;\n    }) : [];\n  };\n\n  Field.prototype.remove = function remove(ns) {\n    var _this10 = this;\n\n    if (typeof ns === 'string') {\n      ns = [ns];\n    }\n\n    var names = ns || Object.keys(this.fieldsMeta);\n    names.forEach(function (name) {\n      if (name in _this10.fieldsMeta) {\n        delete _this10.fieldsMeta[name];\n      }\n    });\n  };\n\n  Field.prototype._resetError = function _resetError(name) {\n    var field = this._get(name);\n\n    delete field.errors; //清空错误\n\n    field.state = '';\n  }; //trigger rerender\n\n\n  Field.prototype._reRender = function _reRender() {\n    if (this.com) {\n      if (!this.options.forceUpdate && this.com.setState) {\n        this.com.setState({});\n      } else if (this.com.forceUpdate) {\n        this.com.forceUpdate(); //forceUpdate 对性能有较大的影响，成指数上升\n      }\n    }\n  };\n\n  Field.prototype._get = function _get(name) {\n    return name in this.fieldsMeta ? this.fieldsMeta[name] : null;\n  };\n\n  return Field;\n}();\n\nexport default Field;","map":null,"metadata":{},"sourceType":"module"}