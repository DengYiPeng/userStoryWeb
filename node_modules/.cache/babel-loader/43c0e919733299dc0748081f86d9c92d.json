{"ast":null,"code":"import _extends from 'babel-runtime/helpers/extends';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\n\nvar _class, _temp;\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { func, obj, KEYCODE, env } from '../util';\nimport Tag from '../tag';\nimport Input from '../input';\nimport Icon from '../icon';\nimport Base from './base';\nimport { isNull, getValueDataSource, valueToSelectKey } from './util';\nvar bindCtx = func.bindCtx,\n    noop = func.noop;\nvar isIE9 = env.ieVersion === 9;\n/**\n * 无障碍化注意事项:\n * 1. Select 无搜索情况下，不应该让 Input 可focus，此时外层wrap必须可focus，并且需要相应focus事件让外边框发生变化\n */\n// 自定义弹层：1. 不需要关心Menu的点击事件 2. 不需要关心dataSource变化\n\n/**\n * Select\n */\n\nvar Select = (_temp = _class = function (_Base) {\n  _inherits(Select, _Base);\n\n  function Select(props) {\n    _classCallCheck(this, Select); // @extend Base state\n\n\n    var _this = _possibleConstructorReturn(this, _Base.call(this, props));\n\n    _this.handleWrapClick = function (e) {\n      e.preventDefault();\n\n      _this.focusInput();\n    };\n\n    _this.handleArrowClick = function (e) {\n      e.preventDefault();\n\n      _this.focusInput();\n\n      _this.setVisible(!_this.state.visible);\n    };\n\n    _this.handleClear = function (e) {\n      e.stopPropagation();\n\n      _this.handleChange(undefined, 'clear');\n    };\n\n    _extends(_this.state, {\n      // search keyword\n      searchValue: 'searchValue' in props ? props.searchValue : ''\n    }); // For cache choosen value\n\n\n    _this.valueDataSource = {\n      valueDS: [],\n      // [{value,label}]\n      mapValueDS: {} // {value: {value,label}}\n\n    };\n    bindCtx(_this, ['handleMenuSelect', 'handleItemClick', 'handleSearch', 'handleSearchKeyDown', 'handleSelectAll']);\n    return _this;\n  }\n\n  Select.prototype.componentWillMount = function componentWillMount() {\n    this.dataStore.setOptions({\n      key: this.state.searchValue,\n      addonKey: this.props.mode === 'tag' // tag 模式手动输入的数据\n\n    });\n\n    _Base.prototype.componentWillMount.call(this); // 根据value和计算后的dataSource，更新value对应的详细数据valueDataSource\n\n\n    if (typeof this.state.value !== 'undefined') {\n      this.valueDataSource = getValueDataSource(this.state.value, this.valueDataSource.mapValueDS, this.dataStore.getMapDS());\n    }\n\n    if (isIE9) {\n      this.ie9Hack();\n    }\n  };\n\n  Select.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    if ('searchValue' in nextProps) {\n      this.dataStore.setOptions({\n        key: nextProps.searchValue\n      });\n      this.setState({\n        searchValue: typeof nextProps.searchValue === 'undefined' ? '' : nextProps.searchValue\n      });\n    }\n\n    if (this.props.mode !== nextProps.mode) {\n      this.dataStore.setOptions({\n        addonKey: nextProps.mode === 'tag'\n      });\n    }\n\n    _Base.prototype.componentWillReceiveProps.call(this, nextProps);\n\n    if ('value' in nextProps) {\n      // under controll\n      this.valueDataSource = getValueDataSource(nextProps.value, this.valueDataSource.mapValueDS, this.dataStore.getMapDS());\n    } else if ('defaultValue' in nextProps && (nextProps.children !== this.props.children || nextProps.dataSource !== this.props.dataSource)) {\n      //has defaultValue and dataSource changed\n      this.valueDataSource = getValueDataSource(nextProps.defaultValue, this.valueDataSource.mapValueDS, this.dataStore.getMapDS());\n    }\n  };\n\n  Select.prototype.componentDidMount = function componentDidMount() {\n    if (isIE9) {\n      this.ie9Hack();\n    }\n\n    _Base.prototype.componentDidMount.call(this);\n  }; // ie9 下 table-cell 布局不支持宽度超出隐藏\n\n\n  Select.prototype.ie9Hack = function ie9Hack() {\n    try {\n      var width = this.selectDOM.currentStyle.width;\n      this.setState({\n        fixWidth: width !== 'auto'\n      });\n    } catch (e) {//\n    }\n  };\n\n  Select.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    var props = this.props; // 随着输入自动伸展\n\n    if (/tag|multiple/.test(props.mode) && prevState.searchValue !== this.state.searchValue) {\n      this.syncWidth();\n    } else {\n      return _Base.prototype.componentDidUpdate.call(this, prevProps, prevState);\n    }\n  };\n\n  Select.prototype.useDetailValue = function useDetailValue() {\n    var _props = this.props,\n        popupContent = _props.popupContent,\n        useDetailValue = _props.useDetailValue,\n        dataSource = _props.dataSource;\n    return useDetailValue || popupContent && !dataSource;\n  };\n\n  Select.prototype.hasSearch = function hasSearch() {\n    var _props2 = this.props,\n        showSearch = _props2.showSearch,\n        mode = _props2.mode;\n    return showSearch || mode === 'tag';\n  };\n  /**\n   * Menu.Item onSelect\n   * @private\n   * @param  {Array<string>} keys\n   */\n\n\n  Select.prototype.handleMenuSelect = function handleMenuSelect(keys) {\n    var _props3 = this.props,\n        mode = _props3.mode,\n        readOnly = _props3.readOnly,\n        disabled = _props3.disabled;\n\n    if (readOnly || disabled) {\n      return false;\n    }\n\n    var isSingle = mode === 'single';\n\n    if (isSingle) {\n      // 单选\n      return this.handleSingleSelect(keys[0], 'itemClick');\n    } else {\n      // 正常多选\n      return this.handleMultipleSelect(keys, 'itemClick');\n    }\n  };\n\n  Select.prototype.handleItemClick = function handleItemClick() {\n    this.focusInput();\n  };\n  /**\n   * 单选模式\n   */\n\n\n  Select.prototype.handleSingleSelect = function handleSingleSelect(key, triggerType) {\n    var cacheValue = this.props.cacheValue; // get data only from dataStore while cacheValue=false\n\n    var itemObj = getValueDataSource(key, cacheValue ? this.valueDataSource.mapValueDS : {}, this.dataStore.getMapDS());\n    this.valueDataSource = itemObj;\n    this.setVisible(false, triggerType);\n\n    if (this.useDetailValue()) {\n      return this.handleChange(itemObj.valueDS, triggerType);\n    } else {\n      this.handleChange(itemObj.value, triggerType, itemObj.valueDS);\n    }\n\n    this.setState({\n      highlightKey: key\n    }); // 清空搜索\n\n    if (!('searchValue' in this.props) && this.state.searchValue) {\n      this.handleSearchClear(triggerType);\n    }\n  };\n  /**\n   * 多选模式 multiple/tag\n   */\n\n\n  Select.prototype.handleMultipleSelect = function handleMultipleSelect(keys, triggerType) {\n    var _this2 = this;\n\n    var itemObj = getValueDataSource(keys, this.valueDataSource.mapValueDS, this.dataStore.getMapDS());\n    var _props4 = this.props,\n        cacheValue = _props4.cacheValue,\n        mode = _props4.mode,\n        hiddenSelected = _props4.hiddenSelected; // 非受控更新缓存map\n\n    if (cacheValue || mode === 'tag') {\n      this.valueDataSource = itemObj;\n    }\n\n    if (hiddenSelected) {\n      this.setVisible(false, triggerType);\n    }\n\n    if (this.useDetailValue()) {\n      this.handleChange(itemObj.valueDS, triggerType);\n    } else {\n      this.handleChange(itemObj.value, triggerType, itemObj.valueDS);\n    } // 清空搜索\n\n\n    if (!('searchValue' in this.props) && this.state.searchValue) {\n      // 因为 SearchValue 被 clear 后会重新渲染 Menu，所以在 Overlay 检测 safeNode 的时候 e.target 可能会找不到导致弹窗关闭\n      setTimeout(function () {\n        _this2.handleSearchClear(triggerType);\n      });\n    }\n  };\n\n  Select.prototype.handleSearchValue = function handleSearchValue(value) {\n    if (this.state.searchValue === value) {\n      return;\n    }\n\n    var filterLocal = this.props.filterLocal;\n\n    if (filterLocal) {\n      if (!('searchValue' in this.props)) {\n        this.setState({\n          searchValue: value,\n          dataSource: this.dataStore.updateByKey(value)\n        });\n        this.setFirstHightLightKeyForMenu();\n      }\n    } else if (!('searchValue' in this.props)) {\n      this.setState({\n        searchValue: value\n      });\n    }\n  };\n  /**\n   * Handle search input change event\n   * @param {Event} e change Event\n   */\n\n\n  Select.prototype.handleSearch = function handleSearch(value) {\n    this.handleSearchValue(value); // inputing should trigger popup open\n\n    if (!this.state.visible && value) {\n      this.setVisible(true);\n    }\n\n    this.props.onSearch(value);\n  };\n\n  Select.prototype.handleSearchClear = function handleSearchClear(triggerType) {\n    this.handleSearchValue('');\n    this.props.onSearchClear(triggerType);\n  }; // 搜索框 keyDown 事件\n\n\n  Select.prototype.handleSearchKeyDown = function handleSearchKeyDown(e) {\n    var _props5 = this.props,\n        popupContent = _props5.popupContent,\n        onKeyDown = _props5.onKeyDown,\n        showSearch = _props5.showSearch,\n        mode = _props5.mode,\n        hasClear = _props5.hasClear,\n        onToggleHighlightItem = _props5.onToggleHighlightItem;\n\n    if (popupContent) {\n      return onKeyDown(e);\n    }\n\n    var proxy = 'search';\n    var hasSearch = this.hasSearch();\n\n    switch (e.keyCode) {\n      case KEYCODE.UP:\n        e.preventDefault();\n        onToggleHighlightItem(this.toggleHighlightItem(-1, e), 'up');\n        break;\n\n      case KEYCODE.DOWN:\n        e.preventDefault();\n        onToggleHighlightItem(this.toggleHighlightItem(1, e), 'down');\n        break;\n\n      case KEYCODE.ENTER:\n        e.preventDefault();\n        this.chooseHighlightItem(proxy, e);\n        break;\n\n      case KEYCODE.ESC:\n        e.preventDefault();\n        this.state.visible && this.setVisible(false, 'keyDown');\n        break;\n\n      case KEYCODE.SPACE:\n        e.stopPropagation();\n        !hasSearch && e.preventDefault();\n        break;\n\n      case KEYCODE.BACKSPACE:\n        if (mode === 'multiple' && showSearch || mode === 'tag') {\n          // 在多选并且有搜索的情况下，删除最后一个 tag\n          this.handleDeleteTag(e);\n        } else if (mode === 'single' && hasClear && !this.state.visible) {\n          // 单选、非展开、并且可清除的情况，允许按删除键清除\n          this.handleClear(e);\n        }\n\n        break;\n\n      default:\n        break;\n    }\n\n    onKeyDown(e);\n  }; // 回车 选择高亮的 item\n\n\n  Select.prototype.chooseHighlightItem = function chooseHighlightItem(proxy, e) {\n    var prevVisible = this.state.visible;\n\n    if (!prevVisible) {\n      return false;\n    }\n\n    var highlightKey = this.state.highlightKey; // 没有高亮选项 或者 没有可选菜单\n\n    if (highlightKey === null || !this.dataStore.getMenuDS().length) {\n      return;\n    }\n\n    var mode = this.props.mode;\n\n    if (mode === 'single') {\n      this.handleSingleSelect(highlightKey, 'enter');\n    } else {\n      var value = this.state.value || [];\n      var keys = value.map(function (v) {\n        return valueToSelectKey(v);\n      });\n      var index = keys.map(function (v) {\n        return '' + v;\n      }).indexOf(highlightKey);\n\n      if (index > -1) {\n        // 反选\n        keys.splice(index, 1);\n      } else {\n        // 勾选\n        keys.push(highlightKey);\n      }\n\n      this.handleMultipleSelect(keys, 'enter'); // 阻止事件冒泡到最外层，让Popup 监听到触发弹层关闭\n\n      e && e.stopPropagation();\n    }\n  };\n  /**\n   * Handle Tag close event\n   * @param  {Object} item\n   * @return {Boolean} false  return false to prevent auto close\n   * ----\n   * It MUST be multiple mode, needn't additional judgement\n   */\n\n\n  Select.prototype.handleTagClose = function handleTagClose(item) {\n    if (this.useDetailValue()) {\n      var value = this.state.value.filter(function (v) {\n        return item.value !== v.value;\n      });\n      this.handleChange(value, 'tag');\n    } else {\n      // filter out current item, and then call handleMenuSelect\n      var _value = this.state.value.filter(function (v) {\n        return item.value !== v;\n      });\n\n      this.handleMultipleSelect(_value, 'tag');\n    }\n\n    this.props.onRemove(item); // prevent tag close\n\n    return false;\n  };\n  /**\n   * Handle BACKSPACE key event\n   * @param {Event} e keyDown event\n   * ---\n   * It MUST be multiple mode\n   */\n\n\n  Select.prototype.handleDeleteTag = function handleDeleteTag(e) {\n    var value = this.state.value;\n    var searchValue = this.state.searchValue;\n\n    if (searchValue || !value || !value.length) {\n      return false;\n    }\n\n    e.preventDefault();\n    var nextValues = value.slice(0, value.length - 1); // 手动调用 handleMenuSelect 时直接传入原生的 value，可以减少 toString 的操作\n\n    if (this.useDetailValue()) {\n      this.handleChange(nextValues, 'tag');\n    } else {\n      this.handleMultipleSelect(nextValues, 'tag');\n    }\n  };\n  /**\n   * Handle SelectAll span click event\n   * @param {Event} e click event\n   */\n\n\n  Select.prototype.handleSelectAll = function handleSelectAll(e) {\n    e && e.preventDefault();\n    var nextValues = this.dataStore.getEnableDS().map(function (item) {\n      return item.value;\n    }); // 直接传 values，减少 toString 操作\n\n    this.handleMultipleSelect(nextValues, 'selectAll');\n  };\n\n  Select.prototype.handleVisibleChange = function handleVisibleChange(visible, type) {\n    this.setVisible(visible, type);\n  };\n\n  Select.prototype.afterClose = function afterClose() {\n    // 关闭的时候清空搜索值\n    if (this.hasSearch()) {\n      this.handleSearchClear('popupClose');\n    }\n  };\n  /**\n   * 如果用户是自定义的弹层，则直接以 value 为准，不再校验 dataSource\n   * @param {object} props\n   */\n\n\n  Select.prototype.renderValues = function renderValues() {\n    var _this3 = this;\n\n    var _props6 = this.props,\n        mode = _props6.mode,\n        size = _props6.size,\n        valueRender = _props6.valueRender,\n        fillProps = _props6.fillProps,\n        disabled = _props6.disabled;\n    var value = this.state.value;\n\n    if (isNull(value)) {\n      return null;\n    } // get detail value\n\n\n    if (!this.useDetailValue()) {\n      value = this.valueDataSource.valueDS;\n    }\n\n    if (mode === 'single') {\n      if (!value) {\n        return null;\n      }\n\n      var retvalue = fillProps ? value[fillProps] : valueRender(value); // 0 => '0'\n\n      return typeof retvalue === 'number' ? retvalue.toString() : retvalue;\n    } else if (value) {\n      if (!Array.isArray(value)) {\n        value = [value];\n      }\n\n      return value.map(function (v) {\n        if (!v) {\n          return null;\n        }\n\n        var labelNode = fillProps ? v[fillProps] : valueRender(v);\n        return React.createElement(Tag, {\n          key: v.value,\n          disabled: disabled || v.disabled,\n          type: 'primary',\n          size: size === 'large' ? 'medium' : 'small',\n          animation: false,\n          onClose: _this3.handleTagClose.bind(_this3, v),\n          closable: true\n        }, labelNode);\n      });\n    }\n\n    return null;\n  };\n  /**\n   * 1. fix flash while click <label/>\n   * 2. fix onBlur while has clear\n   */\n\n\n  Select.prototype.hasClear = function hasClear() {\n    var _props7 = this.props,\n        hasClear = _props7.hasClear,\n        readOnly = _props7.readOnly,\n        disabled = _props7.disabled,\n        mode = _props7.mode,\n        showSearch = _props7.showSearch;\n    var _state = this.state,\n        value = _state.value,\n        visible = _state.visible;\n    return typeof value !== 'undefined' && hasClear && !readOnly && !disabled && mode === 'single' && !(showSearch && visible);\n  };\n  /**\n   * render arrow\n   * @param {object} props\n   * @param {function} [clickHandler]\n   */\n\n\n  Select.prototype.renderExtraNode = function renderExtraNode() {\n    var _props8 = this.props,\n        hasArrow = _props8.hasArrow,\n        hasClear = _props8.hasClear,\n        prefix = _props8.prefix;\n    var ret = [];\n\n    if (hasArrow) {\n      ret.push(React.createElement('span', {\n        key: 'arrow',\n        onClick: this.handleArrowClick,\n        className: prefix + 'select-arrow'\n      }, React.createElement(Icon, {\n        type: 'arrow-down'\n      })));\n    } // 不能使用 this.hasClear() 方法判断，要保证 clear 按钮 dom 结构一直存在，防止其不能成为弹层的安全节点，导致弹层没有必要的显示或隐藏\n\n\n    if (hasClear) {\n      ret.push(React.createElement('span', {\n        key: 'clear',\n        onClick: this.handleClear,\n        className: prefix + 'select-clear'\n      }, React.createElement(Icon, {\n        type: 'delete-filling'\n      })));\n    }\n\n    return ret;\n  };\n  /**\n   * 选择器\n   * @override\n   * @param {object} props\n   */\n\n\n  Select.prototype.renderSelect = function renderSelect() {\n    var _classNames,\n        _this4 = this;\n\n    var _props9 = this.props,\n        prefix = _props9.prefix,\n        showSearch = _props9.showSearch,\n        placeholder = _props9.placeholder,\n        mode = _props9.mode,\n        size = _props9.size,\n        className = _props9.className,\n        style = _props9.style,\n        readOnly = _props9.readOnly,\n        disabled = _props9.disabled,\n        hasBorder = _props9.hasBorder,\n        label = _props9.label,\n        locale = _props9.locale,\n        state = _props9.state,\n        onBlur = _props9.onBlur,\n        onFocus = _props9.onFocus,\n        rtl = _props9.rtl;\n    var others = obj.pickOthers(Select.propTypes, this.props);\n    var othersData = obj.pickAttrsWith(others, 'data-');\n    var visible = this.state.visible;\n    var isSingle = mode === 'single';\n    var hasSearch = this.hasSearch();\n    var valueNodes = this.renderValues(); // compatible with selectPlaceHolder. TODO: removed in 2.0 version\n\n    var _placeholder = placeholder || locale.selectPlaceholder || locale.selectPlaceHolder;\n\n    if (valueNodes && valueNodes.length) {\n      _placeholder = null;\n    } // 弹窗展开时将当前的值作为 placeholder，这个功能的前提是 valueNode 必须是一个字符串\n\n\n    if (showSearch && visible && isSingle && typeof valueNodes === 'string') {\n      _placeholder = valueNodes;\n    } // 下拉箭头\n\n\n    var extra = this.renderExtraNode();\n    var triggerClazz = classNames([prefix + 'select', prefix + 'select-trigger', prefix + 'select-' + mode, '' + prefix + size, className], (_classNames = {}, _classNames[prefix + 'active'] = visible, _classNames[prefix + 'inactive'] = !visible, _classNames[prefix + 'no-search'] = !hasSearch, _classNames[prefix + 'has-search'] = hasSearch, _classNames[prefix + 'select-in-ie'] = isIE9, _classNames[prefix + 'select-in-ie-fixwidth'] = this.state.fixWidth, _classNames[prefix + 'has-clear'] = this.hasClear(), _classNames));\n    var valuetext = this.valueDataSource.valueDS ? this.valueDataSource.valueDS.label : '';\n    return React.createElement('span', _extends({}, othersData, {\n      className: triggerClazz,\n      style: style,\n      dir: rtl ? 'rtl' : undefined,\n      ref: this.saveSelectRef,\n      onClick: this.handleWrapClick,\n      onMouseDown: this.handleWrapClick\n    }), React.createElement(Input, _extends({\n      'aria-valuetext': valuetext\n    }, obj.pickOthers(othersData, others), {\n      role: 'combobox',\n      tabIndex: 0,\n      'aria-expanded': this.state.visible,\n      'aria-disabled': disabled,\n      state: state,\n      label: label,\n      extra: extra,\n      value: this.state.searchValue,\n      size: size,\n      readOnly: !this.hasSearch() || readOnly,\n      disabled: disabled,\n      placeholder: _placeholder,\n      hasBorder: hasBorder,\n      hasClear: false,\n      htmlSize: '1',\n      inputRender: function inputRender(inputEl) {\n        return _this4.renderSearchInput(valueNodes, _placeholder, inputEl);\n      },\n      onChange: this.handleSearch,\n      onKeyDown: this.handleSearchKeyDown,\n      onFocus: onFocus,\n      onBlur: onBlur,\n      className: prefix + 'select-inner',\n      ref: this.saveInputRef\n    })));\n  };\n\n  Select.prototype.renderSearchInput = function renderSearchInput(valueNodes, placeholder, inputEl) {\n    var _classNames2;\n\n    var _props10 = this.props,\n        prefix = _props10.prefix,\n        mode = _props10.mode;\n    var isSingle = mode === 'single';\n    var mirrorText = this.state.searchValue;\n    var cls = classNames((_classNames2 = {}, _classNames2[prefix + 'select-values'] = true, _classNames2[prefix + 'input-text-field'] = true, _classNames2));\n    return React.createElement('span', {\n      className: cls\n    }, isSingle && valueNodes ? React.createElement('em', null, valueNodes) : valueNodes, React.createElement('span', {\n      className: prefix + 'select-trigger-search'\n    }, inputEl, React.createElement('span', {\n      'aria-hidden': true\n    }, mirrorText || placeholder, '\\xA0')));\n  };\n  /**\n   * 渲染弹层的 header 内容\n   * @override\n   * @param {object} props\n   */\n\n\n  Select.prototype.renderMenuHeader = function renderMenuHeader() {\n    var _props11 = this.props,\n        prefix = _props11.prefix,\n        hasSelectAll = _props11.hasSelectAll,\n        mode = _props11.mode;\n    var sourceCount = this.dataStore.getEnableDS().length; // 多选模式下才有全选\n\n    if (!hasSelectAll || mode === 'single' || !sourceCount) {\n      return null;\n    }\n\n    var text = typeof hasSelectAll === 'boolean' ? 'Select All' : hasSelectAll;\n    return React.createElement('div', {\n      key: 'all',\n      onClick: this.handleSelectAll,\n      className: prefix + 'select-all'\n    }, React.createElement('span', null, text));\n  };\n\n  Select.prototype.render = function render() {\n    var mode = this.props.mode;\n\n    var props = _extends({}, this.props); // 搜索的时候不允许回车触发关闭\n\n\n    if (this.hasSearch()) {\n      props.canCloseByTrigger = false;\n    }\n\n    if (mode === 'single') {\n      props.cache = true;\n    }\n\n    return _Base.prototype.render.call(this, props);\n  };\n\n  return Select;\n}(Base), _class.propTypes = _extends({}, Base.propTypes, {\n  /**\n   * 选择器模式\n   */\n  mode: PropTypes.oneOf(['single', 'multiple', 'tag']),\n\n  /**\n   * 当前值，用于受控模式\n   */\n  value: PropTypes.any,\n\n  /**\n   * 初始的默认值\n   */\n  defaultValue: PropTypes.any,\n\n  /**\n   * Select发生改变时触发的回调\n   * @param {*} value 选中的值\n   * @param {String} actionType 触发的方式, 'itemClick', 'enter', 'tag'\n   * @param {*} item 选中的值的对象数据 (useDetailValue=false有效)\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * 传入的数据源，可以动态渲染子项，详见 [dataSource的使用](#dataSource的使用)\n   */\n  dataSource: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.shape({\n    value: PropTypes.any,\n    label: PropTypes.any,\n    disabled: PropTypes.bool,\n    children: PropTypes.array\n  }), PropTypes.bool, PropTypes.number, PropTypes.string])),\n\n  /**\n   * 是否有边框\n   */\n  hasBorder: PropTypes.bool,\n\n  /**\n   * 是否有下拉箭头\n   */\n  hasArrow: PropTypes.bool,\n\n  /**\n   * 展开后是否能搜索（tag 模式下固定为true）\n   */\n  showSearch: PropTypes.bool,\n\n  /**\n   * 当搜索框值变化时回调\n   * @param {String} value 数据\n   */\n  onSearch: PropTypes.func,\n\n  /**\n   * 当搜索框值被清空时候的回调\n   * @param {String} actionType 触发的方式, 'select'(选择清空), 'popupClose'(弹窗关闭清空)\n   */\n  onSearchClear: PropTypes.func,\n\n  /**\n   * 多选模式下是否有全选功能\n   */\n  hasSelectAll: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]),\n\n  /**\n   * 填充到选择框里的值的 key\b\b\n   */\n  fillProps: PropTypes.string,\n\n  /**\n   * onChange 返回的 value 使用 dataSource 的对象\n   */\n  useDetailValue: PropTypes.bool,\n\n  /**\n   * dataSource 变化的时是否保留已选的内容\n   */\n  cacheValue: PropTypes.bool,\n\n  /**\n   * 渲染 Select 展现内容的方法\n   * @param {Object} item 渲染节点的item\n   * @return {ReactNode} 展现内容\n   * @default item => item.label \\|\\| item.value\n   */\n  valueRender: PropTypes.func,\n\n  /**\n   * 渲染 MenuItem 内容的方法\n   * @param {Object} item 渲染节点的item\n   * @param {String} searchValue 搜索关键字（如果开启搜索）\n   * @return {ReactNode} item node\n   */\n  itemRender: PropTypes.func,\n\n  /**\n   * 弹层内容为空的文案\n   */\n  notFoundContent: PropTypes.node,\n  style: PropTypes.object,\n\n  /**\n   * 受控搜索值，一般不需要设置\n   * @type {[type]}\n   */\n  searchValue: PropTypes.string,\n\n  /**\n   * 选择后是否立即隐藏菜单 (mode=multiple/tag 模式生效)\n   */\n  hiddenSelected: PropTypes.bool,\n\n  /**\n   * tag 删除回调\n   * @param {object} item 渲染节点的item\n   */\n  onRemove: PropTypes.func,\n\n  /**\n   * 焦点事件\n   */\n  onFocus: PropTypes.func,\n\n  /**\n   * 失去焦点事件\n   */\n  onBlur: PropTypes.func,\n  onKeyDown: PropTypes.func\n}), _class.defaultProps = _extends({}, Base.defaultProps, {\n  mode: 'single',\n  showSearch: false,\n  cacheValue: true,\n  onSearch: noop,\n  onSearchClear: noop,\n  hasArrow: true,\n  onRemove: noop,\n  valueRender: function valueRender(item) {\n    return item.label || item.value;\n  },\n  onKeyDown: noop,\n  onFocus: noop,\n  onBlur: noop\n}), _class.displayName = 'Select', _temp);\nexport default Select;","map":null,"metadata":{},"sourceType":"module"}