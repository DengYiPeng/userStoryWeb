{"ast":null,"code":"import _extends from 'babel-runtime/helpers/extends';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport { complementError, asyncMap } from './util';\nimport { getValidationMethod } from './validator';\nimport defaultMessages from './messages';\n\nfunction noop() {}\n\nvar Schema = function () {\n  function Schema(rules) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Schema);\n\n    this._rules = rules;\n    this._options = _extends({}, options, {\n      messages: _extends({}, defaultMessages, options.messages)\n    });\n    this.complete = [];\n  }\n\n  Schema.prototype.abort = function abort() {\n    for (var i = 0; i < this.complete.length; i++) {\n      this.complete[i] = noop;\n    }\n  };\n\n  Schema.prototype.messages = function messages(_messages) {\n    this._options.messages = _extends({}, this._options.messages, _messages);\n  };\n\n  Schema.prototype.validate = function validate(source, callback) {\n    var _this = this;\n\n    if (!this._rules || Object.keys(this._rules).length === 0) {\n      if (callback) {\n        callback(null);\n      }\n\n      return;\n    } // serialize rules\n\n\n    var arr = void 0;\n    var value = void 0;\n    var series = {};\n    var names = Object.keys(this._rules);\n    names.forEach(function (name) {\n      arr = _this._rules[name];\n      value = source[name];\n\n      if (!Array.isArray(arr)) {\n        arr = [arr];\n      }\n\n      arr.forEach(function (rule) {\n        rule.validator = getValidationMethod(rule);\n        rule.field = name;\n\n        if (!rule.validator) {\n          return;\n        }\n\n        series[name] = series[name] || [];\n        series[name].push({\n          rule: rule,\n          value: value,\n          source: source,\n          field: name\n        });\n      });\n    });\n\n    if (Object.keys(series).length === 0) {\n      callback(null);\n    } // callback function for all rules return\n\n\n    function complete(results) {\n      var i = void 0;\n      var field = void 0;\n      var errors = [];\n      var fields = {};\n\n      function add(e) {\n        if (Array.isArray(e)) {\n          errors = errors.concat(e);\n        } else {\n          errors.push(e);\n        }\n      }\n\n      for (i = 0; i < results.length; i++) {\n        add(results[i]);\n      }\n\n      if (!errors.length) {\n        errors = null;\n        fields = null;\n      } else {\n        for (i = 0; i < errors.length; i++) {\n          field = errors[i].field;\n          fields[field] = fields[field] || [];\n          fields[field].push(errors[i]);\n        }\n      }\n\n      callback(errors, fields);\n    }\n\n    this.complete.push(complete);\n    var idx = this.complete.length; // async validate\n\n    asyncMap(series, this._options, function (data, doIt) {\n      var rule = data.rule;\n      rule.field = data.field;\n\n      function cb() {\n        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        var errors = e;\n\n        if (!Array.isArray(errors)) {\n          errors = [errors];\n        } // 自定义错误\n\n\n        if (errors.length && rule.message) {\n          errors = [].concat(rule.message);\n        }\n\n        errors = errors.map(complementError(rule));\n        doIt(errors);\n      }\n\n      var res = rule.validator(rule, data.value, cb, _this._options);\n\n      if (res && res.then) {\n        res.then(function () {\n          return cb();\n        }, function (e) {\n          return cb(e);\n        });\n      }\n    }, function (results) {\n      _this.complete[idx - 1](results);\n    });\n  };\n\n  return Schema;\n}();\n\nexport default Schema;","map":null,"metadata":{},"sourceType":"module"}