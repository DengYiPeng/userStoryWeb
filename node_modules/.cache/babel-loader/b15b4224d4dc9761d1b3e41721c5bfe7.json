{"ast":null,"code":"import _extends from 'babel-runtime/helpers/extends';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\n\nvar _class, _temp;\n\nimport React, { Component, Children, cloneElement } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport cx from 'classnames';\nimport { func, obj, KEYCODE } from '../../util';\nvar bindCtx = func.bindCtx;\nvar pickOthers = obj.pickOthers;\n\nvar noop = function noop() {};\n/**\n * Menu\n */\n\n\nvar Menu = (_temp = _class = function (_Component) {\n  _inherits(Menu, _Component);\n\n  function Menu(props) {\n    _classCallCheck(this, Menu);\n\n    var _this = _possibleConstructorReturn(this, _Component.call(this, props));\n\n    var _this$props = _this.props,\n        children = _this$props.children,\n        selectedKeys = _this$props.selectedKeys,\n        defaultSelectedKeys = _this$props.defaultSelectedKeys,\n        focusedKey = _this$props.focusedKey,\n        focusable = _this$props.focusable,\n        autoFocus = _this$props.autoFocus;\n    _this.newChildren = _this.getNewChildren(children);\n\n    if (focusable) {\n      _this.tabbableKey = _this.getFirstAvaliablelChildKey('0');\n    }\n\n    _this.state = {\n      openKeys: _this.getInitOpenKeys(props),\n      selectedKeys: _this.normalizeToArray(selectedKeys || defaultSelectedKeys),\n      focusedKey: 'focusedKey' in _this.props ? focusedKey : focusable && autoFocus ? _this.tabbableKey : null\n    };\n    bindCtx(_this, ['handleOpen', 'handleSelect', 'handleItemClick', 'handleItemKeyDown', 'onBlur']);\n    _this.popupNodes = [];\n    return _this;\n  }\n\n  Menu.prototype.componentDidMount = function componentDidMount() {\n    this.menuNode = findDOMNode(this);\n  };\n\n  Menu.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var state = {};\n\n    if ('openKeys' in nextProps) {\n      state.openKeys = this.normalizeToArray(nextProps.openKeys);\n    }\n\n    if ('selectedKeys' in nextProps) {\n      state.selectedKeys = this.normalizeToArray(nextProps.selectedKeys);\n    }\n\n    if ('focusedKey' in nextProps) {\n      state.focusedKey = nextProps.focusedKey;\n    }\n\n    if (Object.keys(state).length) {\n      this.setState(state);\n    }\n  };\n\n  Menu.prototype.componentWillUpdate = function componentWillUpdate(nextProps) {\n    this.newChildren = this.getNewChildren(nextProps.children);\n\n    if (this.props.focusable) {\n      if (this.tabbableKey in this.k2n) {\n        if (this.state.focusedKey) {\n          this.tabbableKey = this.state.focusedKey;\n        }\n      } else {\n        this.tabbableKey = this.getFirstAvaliablelChildKey('0');\n      }\n    }\n  };\n\n  Menu.prototype.onBlur = function onBlur(e) {\n    this.setState({\n      focusedKey: ''\n    });\n    this.props.onBlur && this.props.onBlur(e);\n  };\n\n  Menu.prototype.getInitOpenKeys = function getInitOpenKeys(props) {\n    var _this2 = this;\n\n    var initOpenKeys = void 0;\n    var openKeys = props.openKeys,\n        defaultOpenKeys = props.defaultOpenKeys,\n        defaultOpenAll = props.defaultOpenAll,\n        mode = props.mode,\n        openMode = props.openMode;\n\n    if (openKeys) {\n      initOpenKeys = openKeys;\n    } else if (defaultOpenAll && mode === 'inline' && openMode === 'multiple') {\n      initOpenKeys = Object.keys(this.k2n).filter(function (key) {\n        return _this2.k2n[key].type === 'submenu';\n      });\n    } else {\n      initOpenKeys = defaultOpenKeys;\n    }\n\n    return this.normalizeToArray(initOpenKeys);\n  };\n\n  Menu.prototype.getNewChildren = function getNewChildren(children) {\n    var _this3 = this;\n\n    this.k2n = {};\n    this.p2n = {};\n\n    var loop = function loop(children, posPrefix) {\n      var indexWrapper = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n        index: 0\n      };\n      return Children.map(children, function (child) {\n        if (child && typeof child.type === 'function' && 'menuChildType' in child.type) {\n          var newChild = void 0;\n          var pos = void 0;\n          var props = {\n            root: _this3\n          };\n\n          if (['item', 'submenu', 'group'].indexOf(child.type.menuChildType) > -1) {\n            pos = posPrefix + '-' + indexWrapper.index++;\n            var key = typeof child.key === 'string' ? child.key : pos;\n            var level = pos.split('-').length - 1;\n            _this3.k2n[key] = _this3.p2n[pos] = {\n              key: key,\n              pos: pos,\n              type: child.type.menuChildType,\n              disabled: child.props.disabled,\n              label: child.props.label || child.props.children\n            };\n            props._key = key;\n            props.level = level;\n            props.groupIndent = child.type.menuChildType === 'group' ? 1 : 0;\n          }\n\n          switch (child.type.menuChildType) {\n            case 'submenu':\n              newChild = cloneElement(child, props, loop(child.props.children, pos));\n              break;\n\n            case 'group':\n              newChild = cloneElement(child, props, loop(child.props.children, posPrefix, indexWrapper));\n              break;\n\n            case 'item':\n            case 'divider':\n              newChild = cloneElement(child, props);\n              break;\n\n            default:\n              newChild = child;\n              break;\n          }\n\n          return newChild;\n        }\n\n        return child;\n      });\n    };\n\n    return loop(children, '0');\n  };\n\n  Menu.prototype.normalizeToArray = function normalizeToArray(items) {\n    if (items) {\n      if (Array.isArray(items)) {\n        return items;\n      }\n\n      return [items];\n    }\n\n    return [];\n  };\n\n  Menu.prototype.isSibling = function isSibling(currentPos, targetPos) {\n    var currentNums = currentPos.split('-').slice(0, -1);\n    var targetNums = targetPos.split('-').slice(0, -1);\n    return currentNums.length === targetNums.length && currentNums.every(function (num, index) {\n      return num === targetNums[index];\n    });\n  };\n\n  Menu.prototype.isAncestor = function isAncestor(currentPos, targetPos) {\n    var currentNums = currentPos.split('-');\n    var targetNums = targetPos.split('-');\n    return currentNums.length > targetNums.length && targetNums.every(function (num, index) {\n      return num === currentNums[index];\n    });\n  };\n\n  Menu.prototype.handleOpen = function handleOpen(key, open, triggerType, e) {\n    var _this4 = this;\n\n    var newOpenKeys = void 0;\n    var _props = this.props,\n        mode = _props.mode,\n        openMode = _props.openMode;\n    var openKeys = this.state.openKeys;\n    var index = openKeys.indexOf(key);\n\n    if (open && index === -1) {\n      if (mode === 'inline') {\n        if (openMode === 'single') {\n          newOpenKeys = openKeys.filter(function (k) {\n            return !_this4.isSibling(_this4.k2n[key].pos, _this4.k2n[k].pos);\n          });\n          newOpenKeys.push(key);\n        } else {\n          newOpenKeys = openKeys.concat(key);\n        }\n      } else {\n        newOpenKeys = openKeys.filter(function (k) {\n          return _this4.isAncestor(_this4.k2n[key].pos, _this4.k2n[k].pos);\n        });\n        newOpenKeys.push(key);\n      }\n    } else if (!open && index > -1) {\n      if (mode === 'inline') {\n        newOpenKeys = [].concat(openKeys.slice(0, index), openKeys.slice(index + 1));\n      } else if (triggerType === 'docClick') {\n        if (!this.popupNodes.concat(this.menuNode).some(function (node) {\n          return node.contains(e.target);\n        })) {\n          newOpenKeys = [];\n        }\n      } else {\n        newOpenKeys = openKeys.filter(function (k) {\n          return k !== key && !_this4.isAncestor(_this4.k2n[k].pos, _this4.k2n[key].pos);\n        });\n      }\n    }\n\n    if (newOpenKeys) {\n      if (!('openKeys' in this.props)) {\n        this.setState({\n          openKeys: newOpenKeys\n        });\n      }\n\n      this.props.onOpen(newOpenKeys, {\n        key: key,\n        open: open\n      });\n    }\n  };\n\n  Menu.prototype.getPath = function getPath(key) {\n    var keyPath = [];\n    var labelPath = [];\n    var pos = this.k2n[key].pos;\n    var nums = pos.split('-');\n\n    for (var i = 1; i < nums.length - 1; i++) {\n      var parentNums = nums.slice(0, i + 1);\n      var parentPos = parentNums.join('-');\n      var parent = this.p2n[parentPos];\n      keyPath.push(parent.key);\n      labelPath.push(parent.label);\n    }\n\n    return {\n      keyPath: keyPath,\n      labelPath: labelPath\n    };\n  };\n\n  Menu.prototype.handleSelect = function handleSelect(key, select, menuItem) {\n    var pos = this.k2n[key].pos;\n    var level = pos.split('-').length - 1;\n\n    if (this.props.shallowSelect && level > 1) {\n      return;\n    }\n\n    var newSelectedKeys = void 0;\n    var selectMode = this.props.selectMode;\n    var selectedKeys = this.state.selectedKeys;\n    var index = selectedKeys.indexOf(key);\n\n    if (select && index === -1) {\n      if (selectMode === 'single') {\n        newSelectedKeys = [key];\n      } else if (selectMode === 'multiple') {\n        newSelectedKeys = selectedKeys.concat(key);\n      }\n    } else if (!select && index > -1 && selectMode === 'multiple') {\n      newSelectedKeys = [].concat(selectedKeys.slice(0, index), selectedKeys.slice(index + 1));\n    }\n\n    if (newSelectedKeys) {\n      if (!('selectedKeys' in this.props)) {\n        this.setState({\n          selectedKeys: newSelectedKeys\n        });\n      }\n\n      this.props.onSelect(newSelectedKeys, menuItem, _extends({\n        key: key,\n        select: select,\n        label: this.k2n[key].label\n      }, this.getPath(key)));\n    }\n  };\n\n  Menu.prototype.handleItemClick = function handleItemClick(key, item, e) {\n    var _this5 = this;\n\n    if (this.props.focusable) {\n      if (!('focusedKey' in this.props)) {\n        this.setState({\n          focusedKey: key\n        });\n      }\n\n      this.props.onItemFocus(key, item, e);\n    }\n\n    if (item.props.type === 'item') {\n      if (item.props.parentMode === 'popup' && this.state.openKeys.length) {\n        if (!('openKeys' in this.props)) {\n          this.setState({\n            openKeys: []\n          });\n        }\n\n        this.props.onOpen([], {\n          key: this.state.openKeys.sort(function (prevKey, nextKey) {\n            return _this5.k2n[nextKey].pos.split('-').length - _this5.k2n[prevKey].pos.split('-').length;\n          })[0],\n          open: false\n        });\n      }\n\n      this.props.onItemClick(key, item, e);\n    }\n  };\n\n  Menu.prototype.isAvailablePos = function isAvailablePos(refPos, targetPos) {\n    var _p2n$targetPos = this.p2n[targetPos],\n        type = _p2n$targetPos.type,\n        disabled = _p2n$targetPos.disabled;\n    return this.isSibling(refPos, targetPos) && (type === 'item' && !disabled || type === 'submenu');\n  };\n\n  Menu.prototype.getAvailableKey = function getAvailableKey(pos, prev) {\n    var _this6 = this;\n\n    var ps = Object.keys(this.p2n).filter(function (p) {\n      return _this6.isAvailablePos(pos, p);\n    });\n\n    if (ps.length > 1) {\n      var index = ps.indexOf(pos);\n      var targetIndex = void 0;\n\n      if (prev) {\n        targetIndex = index === 0 ? ps.length - 1 : index - 1;\n      } else {\n        targetIndex = index === ps.length - 1 ? 0 : index + 1;\n      }\n\n      return this.p2n[ps[targetIndex]].key;\n    }\n\n    return null;\n  };\n\n  Menu.prototype.getFirstAvaliablelChildKey = function getFirstAvaliablelChildKey(parentPos) {\n    var _this7 = this;\n\n    var pos = Object.keys(this.p2n).find(function (p) {\n      return _this7.isAvailablePos(parentPos + '-0', p);\n    });\n    return pos ? this.p2n[pos].key : null;\n  };\n\n  Menu.prototype.getParentKey = function getParentKey(pos) {\n    return this.p2n[pos.slice(0, pos.length - 2)].key;\n  };\n\n  Menu.prototype.handleItemKeyDown = function handleItemKeyDown(key, type, item, e) {\n    if ([KEYCODE.UP, KEYCODE.DOWN, KEYCODE.RIGHT, KEYCODE.LEFT, KEYCODE.ENTER, KEYCODE.ESC, KEYCODE.SPACE].indexOf(e.keyCode) > -1) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    var focusedKey = this.state.focusedKey;\n    var direction = this.props.direction;\n    var pos = this.k2n[key].pos;\n    var level = pos.split('-').length - 1;\n\n    switch (e.keyCode) {\n      case KEYCODE.UP:\n        {\n          var avaliableKey = this.getAvailableKey(pos, true);\n\n          if (avaliableKey) {\n            focusedKey = avaliableKey;\n          }\n\n          break;\n        }\n\n      case KEYCODE.DOWN:\n        {\n          var _avaliableKey = void 0;\n\n          if (direction === 'hoz' && level === 1 && type === 'submenu') {\n            this.handleOpen(key, true);\n            _avaliableKey = this.getFirstAvaliablelChildKey(pos);\n          } else {\n            _avaliableKey = this.getAvailableKey(pos, false);\n          }\n\n          if (_avaliableKey) {\n            focusedKey = _avaliableKey;\n          }\n\n          break;\n        }\n\n      case KEYCODE.RIGHT:\n        {\n          var _avaliableKey2 = void 0;\n\n          if (direction === 'hoz' && level === 1) {\n            _avaliableKey2 = this.getAvailableKey(pos, false);\n          } else if (type === 'submenu') {\n            this.handleOpen(key, true);\n            _avaliableKey2 = this.getFirstAvaliablelChildKey(pos);\n          }\n\n          if (_avaliableKey2) {\n            focusedKey = _avaliableKey2;\n          }\n\n          break;\n        }\n\n      case KEYCODE.ENTER:\n        {\n          if (type === 'submenu') {\n            this.handleOpen(key, true);\n\n            var _avaliableKey3 = this.getFirstAvaliablelChildKey(pos);\n\n            if (_avaliableKey3) {\n              focusedKey = _avaliableKey3;\n            }\n          }\n\n          break;\n        }\n\n      case KEYCODE.LEFT:\n        {\n          if (direction === 'hoz' && level === 1) {\n            var _avaliableKey4 = this.getAvailableKey(pos, true);\n\n            if (_avaliableKey4) {\n              focusedKey = _avaliableKey4;\n            }\n          } else if (level > 1) {\n            var parentKey = this.getParentKey(pos);\n            this.handleOpen(parentKey, false);\n            focusedKey = parentKey;\n          }\n\n          break;\n        }\n\n      case KEYCODE.ESC:\n        if (level > 1) {\n          var _parentKey = this.getParentKey(pos);\n\n          this.handleOpen(_parentKey, false);\n          focusedKey = _parentKey;\n        }\n\n        break;\n\n      case KEYCODE.TAB:\n        focusedKey = null;\n        break;\n\n      default:\n        break;\n    }\n\n    if (focusedKey !== this.state.focusedKey) {\n      if (!('focusedKey' in this.props)) {\n        this.setState({\n          focusedKey: focusedKey\n        });\n      }\n\n      this.props.onItemKeyDown(focusedKey, item, e);\n      this.props.onItemFocus(focusedKey, e);\n    }\n  };\n\n  Menu.prototype.render = function render() {\n    var _cx;\n\n    var _props2 = this.props,\n        prefix = _props2.prefix,\n        className = _props2.className,\n        direction = _props2.direction,\n        hozAlign = _props2.hozAlign,\n        header = _props2.header,\n        footer = _props2.footer,\n        selectMode = _props2.selectMode,\n        rtl = _props2.rtl;\n    var others = pickOthers(Object.keys(Menu.propTypes), this.props);\n    var newClassName = cx((_cx = {}, _cx[prefix + 'menu'] = true, _cx[prefix + 'ver'] = direction === 'ver', _cx[prefix + 'hoz'] = direction === 'hoz', _cx[className] = !!className, _cx));\n    var role = direction === 'hoz' ? 'menubar' : 'menu';\n    var headerElement = header ? React.createElement('li', {\n      className: prefix + 'menu-header'\n    }, header) : null;\n    var itemsElement = header || footer ? React.createElement('ul', {\n      className: prefix + 'menu-content'\n    }, this.newChildren) : this.newChildren;\n    var footerElement = footer ? React.createElement('li', {\n      className: prefix + 'menu-footer'\n    }, footer) : null;\n    var shouldWrapItemsAndFooter = hozAlign === 'right' && !!header;\n\n    if (rtl) {\n      others.dir = 'rtl';\n    }\n\n    return React.createElement('ul', _extends({\n      role: role,\n      onBlur: this.onBlur,\n      className: newClassName,\n      onKeyDown: this.handleEnter,\n      'aria-multiselectable': selectMode === 'multiple'\n    }, others), headerElement, shouldWrapItemsAndFooter ? React.createElement('div', {\n      className: prefix + 'menu-hoz-right'\n    }, itemsElement, footerElement) : null, !shouldWrapItemsAndFooter ? itemsElement : null, !shouldWrapItemsAndFooter ? footerElement : null);\n  };\n\n  return Menu;\n}(Component), _class.isNextMenu = true, _class.propTypes = {\n  prefix: PropTypes.string,\n  pure: PropTypes.bool,\n  rtl: PropTypes.bool,\n  className: PropTypes.string,\n\n  /**\n   * 菜单项和子菜单\n   */\n  children: PropTypes.node,\n\n  /**\n   * 点击菜单项触发的回调函数\n   * @param {String} key 点击的菜单项的 key 值\n   * @param {Object} item 点击的菜单项对象\n   * @param {Object} event 点击的事件对象\n   */\n  onItemClick: PropTypes.func,\n\n  /**\n   * 当前打开的子菜单的 key 值\n   */\n  openKeys: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),\n\n  /**\n   * 初始打开的子菜单的 key 值\n   */\n  defaultOpenKeys: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),\n\n  /**\n   * 初始展开所有的子菜单，只在 mode 设置为 'inline' 以及 openMode 设置为 'multiple' 下生效，优先级高于 defaultOpenKeys\n   */\n  defaultOpenAll: PropTypes.bool,\n\n  /**\n   * 打开或关闭子菜单触发的回调函数\n   * @param {String} key 打开的所有子菜单的 key 值\n   * @param {Object} extra 额外参数\n   * @param {String} extra.key 当前操作子菜单的 key 值\n   * @param {Boolean} extra.open 是否是打开\n   */\n  onOpen: PropTypes.func,\n\n  /**\n   * 子菜单打开的模式\n   */\n  mode: PropTypes.oneOf(['inline', 'popup']),\n\n  /**\n   * 子菜单打开的触发行为\n   */\n  triggerType: PropTypes.oneOf(['click', 'hover']),\n\n  /**\n   * 展开内连子菜单的模式，同时可以展开一个子菜单还是多个子菜单，该属性仅在 mode 为 inline 时生效\n   */\n  openMode: PropTypes.oneOf(['single', 'multiple']),\n\n  /**\n   * 内连子菜单缩进距离\n   */\n  inlineIndent: PropTypes.number,\n  inlineArrowDirection: PropTypes.oneOf(['down', 'right']),\n\n  /**\n   * 是否自动让弹层的宽度和菜单项保持一致，如果弹层的宽度比菜单项小则和菜单项保持一致，如果宽度大于菜单项则不做处理\n   */\n  popupAutoWidth: PropTypes.bool,\n\n  /**\n   * 弹层的对齐方式\n   */\n  popupAlign: PropTypes.oneOf(['follow', 'outside']),\n\n  /**\n   * 弹层自定义 props\n   */\n  popupProps: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),\n\n  /**\n   * 弹出子菜单自定义 className\n   */\n  popupClassName: PropTypes.string,\n\n  /**\n   * 弹出子菜单自定义 style\n   */\n  popupStyle: PropTypes.object,\n\n  /**\n   * 当前选中菜单项的 key 值\n   */\n  selectedKeys: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),\n\n  /**\n   * 初始选中菜单项的 key 值\n   */\n  defaultSelectedKeys: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),\n\n  /**\n   * 选中或取消选中菜单项触发的回调函数\n   * @param {Array} selectedKeys 选中的所有菜单项的值\n   * @param {Object} item 选中或取消选中的菜单项\n   * @param {Object} extra 额外参数\n   * @param {Boolean} extra.select 是否是选中\n   * @param {Array} extra.key 菜单项的 key\n   * @param {Object} extra.label 菜单项的文本\n   * @param {Array} extra.keyPath 菜单项 key 的路径\n   */\n  onSelect: PropTypes.func,\n\n  /**\n   * 选中模式，单选还是多选，默认无值，不可选\n   */\n  selectMode: PropTypes.oneOf(['single', 'multiple']),\n\n  /**\n   * 是否只能选择第一层菜单项（不能选择子菜单中的菜单项）\n   */\n  shallowSelect: PropTypes.bool,\n\n  /**\n   * 是否显示选中图标，如果设置为 false 需配合配置平台设置选中时的背景色以示区分\n   */\n  hasSelectedIcon: PropTypes.bool,\n  labelToggleChecked: PropTypes.bool,\n\n  /**\n   * 菜单第一层展示方向\n   */\n  direction: PropTypes.oneOf(['ver', 'hoz']),\n\n  /**\n   * 横向菜单条 item 和 footer 的对齐方向，在 direction 设置为 'hoz' 并且 header 存在时生效\n   */\n  hozAlign: PropTypes.oneOf(['left', 'right']),\n\n  /**\n   * 自定义菜单头部\n   */\n  header: PropTypes.node,\n\n  /**\n   * 自定义菜单尾部\n   */\n  footer: PropTypes.node,\n\n  /**\n   * 是否自动获得焦点\n   */\n  autoFocus: PropTypes.bool,\n\n  /**\n   * 当前获得焦点的子菜单或菜单项 key 值\n   */\n  focusedKey: PropTypes.string,\n  focusable: PropTypes.bool,\n  onItemFocus: PropTypes.func,\n  onBlur: PropTypes.func,\n  onItemKeyDown: PropTypes.func,\n  expandAnimation: PropTypes.bool,\n  itemClassName: PropTypes.string\n}, _class.defaultProps = {\n  prefix: 'next-',\n  pure: false,\n  defaultOpenKeys: [],\n  defaultOpenAll: false,\n  onOpen: noop,\n  mode: 'inline',\n  triggerType: 'click',\n  openMode: 'multiple',\n  inlineIndent: 20,\n  inlineArrowDirection: 'down',\n  popupAutoWidth: false,\n  popupAlign: 'follow',\n  popupProps: {},\n  defaultSelectedKeys: [],\n  onSelect: noop,\n  shallowSelect: false,\n  hasSelectedIcon: true,\n  labelToggleChecked: true,\n  direction: 'ver',\n  hozAlign: 'left',\n  autoFocus: false,\n  focusable: true,\n  onItemFocus: noop,\n  onItemKeyDown: noop,\n  onItemClick: noop,\n  expandAnimation: true\n}, _temp);\nMenu.displayName = 'Menu';\nexport { Menu as default };","map":null,"metadata":{},"sourceType":"module"}