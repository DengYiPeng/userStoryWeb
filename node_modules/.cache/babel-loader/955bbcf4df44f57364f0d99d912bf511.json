{"ast":null,"code":"import _extends from 'babel-runtime/helpers/extends';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\n\nvar _class, _temp;\n\nimport React, { Children } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { func, dom, events } from '../util';\nimport Menu from '../menu';\nimport Overlay from '../overlay';\nimport zhCN from '../locale/zh-cn';\nimport DataStore from './data-store';\nimport VirtualList from '../virtual-list';\nimport { isSingle, filter, isNull, valueToSelectKey } from './util';\nvar Popup = Overlay.Popup;\nvar MenuItem = Menu.Item,\n    MenuGroup = Menu.Group;\nvar noop = func.noop,\n    bindCtx = func.bindCtx,\n    makeChain = func.makeChain;\n\nfunction preventDefault(e) {\n  e.preventDefault();\n}\n\nvar Base = (_temp = _class = function (_React$Component) {\n  _inherits(Base, _React$Component);\n\n  function Base(props) {\n    _classCallCheck(this, Base);\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));\n\n    _this.saveSelectRef = function (ref) {\n      _this.selectDOM = findDOMNode(ref);\n    };\n\n    _this.saveInputRef = function (ref) {\n      if (ref && ref.getInstance()) {\n        _this.inputRef = ref.getInstance();\n      }\n    };\n\n    _this.savePopupRef = function (ref) {\n      _this.popupRef = ref;\n\n      if (_this.props.popupProps && typeof _this.props.popupProps.ref === 'function') {\n        _this.props.popupProps.ref(ref);\n      }\n    };\n\n    _this.dataStore = new DataStore({\n      filter: props.filter,\n      filterLocal: props.filterLocal\n    });\n    _this.state = {\n      value: 'value' in props ? props.value : props.defaultValue,\n      visible: 'visible' in props ? props.visible : props.defaultVisible,\n      dataSource: [],\n      width: 100,\n      // current highlight key\n      highlightKey: null\n    };\n    bindCtx(_this, ['handleMenuBodyClick', 'handleVisibleChange', 'focusInput', 'beforeOpen', 'beforeClose', 'afterClose', 'handleResize']);\n    return _this;\n  }\n\n  Base.prototype.componentWillMount = function componentWillMount() {\n    this.setState({\n      dataSource: this.setDataSource(this.props)\n    });\n  };\n\n  Base.prototype.componentDidMount = function componentDidMount() {\n    var _this2 = this; // overlay 还没有完成 mount，所以需要滞后同步宽度\n\n\n    setTimeout(function () {\n      return _this2.syncWidth();\n    }, 0);\n    events.on(window, 'resize', this.handleResize);\n  };\n\n  Base.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    if ('value' in nextProps) {\n      this.setState({\n        value: nextProps.value\n      });\n    }\n\n    if ('visible' in nextProps) {\n      // this.state.visible = nextProps.visible;\n      this.setState({\n        visible: nextProps.visible\n      });\n    }\n\n    this.dataStore.setOptions({\n      filter: nextProps.filter,\n      filterLocal: nextProps.filterLocal\n    });\n\n    if (nextProps.children !== this.props.children || nextProps.dataSource !== this.props.dataSource) {\n      var dataSource = this.setDataSource(nextProps);\n      this.setState({\n        dataSource: dataSource\n      });\n    }\n  };\n\n  Base.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    if (prevProps.label !== this.props.label || prevState.value !== this.state.value) {\n      this.syncWidth();\n    }\n  };\n\n  Base.prototype.componentWillUnmount = function componentWillUnmount() {\n    events.off(window, 'resize', this.handleResize);\n    clearTimeout(this.resizeTimeout);\n  };\n  /**\n   * Calculate and set width of popup menu\n   * @protected\n   */\n\n\n  Base.prototype.syncWidth = function syncWidth() {\n    var _this3 = this;\n\n    var width = dom.getStyle(this.selectDOM, 'width');\n\n    if (width && this.width !== width) {\n      this.width = width;\n\n      if (this.popupRef && this.props.autoWidth) {\n        // overy 的 node 节点可能没有挂载完成，所以这里需要异步\n        setTimeout(function () {\n          if (_this3.popupRef && _this3.popupRef.getInstance().overlay) {\n            dom.setStyle(_this3.popupRef.getInstance().overlay.getInstance().getContentNode(), 'width', _this3.width);\n          }\n        }, 0);\n      }\n    }\n  };\n\n  Base.prototype.handleResize = function handleResize() {\n    var _this4 = this;\n\n    clearTimeout(this.resizeTimeout);\n\n    if (this.state.visible) {\n      this.resizeTimeout = setTimeout(function () {\n        _this4.syncWidth();\n      }, 200);\n    }\n  };\n  /**\n   * Get structured dataSource, for cache\n   * @protected\n   * @param  {Object} [props=this.props]\n   * @return {Array}\n   */\n\n\n  Base.prototype.setDataSource = function setDataSource(props) {\n    var dataSource = props.dataSource,\n        children = props.children; // children is higher priority then dataSource\n\n    if (Children.count(children)) {\n      return this.dataStore.updateByDS(children, true);\n    } else if (Array.isArray(dataSource)) {\n      return this.dataStore.updateByDS(dataSource, false);\n    }\n\n    return [];\n  };\n  /**\n   * Set popup visible\n   * @protected\n   * @param {boolean} visible\n   * @param {string} type trigger type\n   */\n\n\n  Base.prototype.setVisible = function setVisible(visible, type) {\n    if (this.props.disabled || this.state.visible === visible) {\n      return;\n    }\n\n    if (!('visible' in this.props)) {\n      this.setState({\n        visible: visible\n      });\n    }\n\n    this.props.onVisibleChange(visible, type);\n  };\n\n  Base.prototype.setFirstHightLightKeyForMenu = function setFirstHightLightKeyForMenu() {\n    // 设置高亮 item key\n    if (this.dataStore.getMenuDS().length && this.dataStore.getEnableDS().length) {\n      this.setState({\n        highlightKey: '' + this.dataStore.getEnableDS()[0].value\n      });\n    }\n  };\n\n  Base.prototype.handleChange = function handleChange(value) {\n    var _props2; // 非受控模式清空内部数据\n\n\n    if (!('value' in this.props)) {\n      this.setState({\n        value: value\n      });\n    }\n\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    (_props2 = this.props).onChange.apply(_props2, [value].concat(args));\n  };\n  /**\n   * Handle Menu body click\n   * @param {Event} e click event\n   */\n\n\n  Base.prototype.handleMenuBodyClick = function handleMenuBodyClick(e) {\n    this.focusInput(e);\n  };\n  /**\n   * Toggle highlight MenuItem\n   * @private\n   * @param {number} dir -1: up, 1: down\n   */\n\n\n  Base.prototype.toggleHighlightItem = function toggleHighlightItem(dir) {\n    if (!this.state.visible) {\n      this.setVisible(true, 'enter');\n      return;\n    }\n\n    var maxCount = this.dataStore.getEnableDS().length; // When there is no enabled item\n\n    if (!maxCount) {\n      return false;\n    }\n\n    var highlightKey = this.state.highlightKey;\n    var highlightIndex = -1; // find previous highlight index\n\n    highlightKey !== null && this.dataStore.getEnableDS().some(function (item, index) {\n      if ('' + item.value === highlightKey) {\n        highlightIndex = index;\n      }\n\n      return highlightIndex > -1;\n    }); // toggle highlight index\n\n    highlightIndex += dir;\n\n    if (highlightIndex < 0) {\n      highlightIndex = maxCount - 1;\n    }\n\n    if (highlightIndex >= maxCount) {\n      highlightIndex = 0;\n    } // get highlight key\n\n\n    var highlightItem = this.dataStore.getEnableDS()[highlightIndex];\n    highlightKey = highlightItem ? '' + highlightItem.value : null;\n    this.setState({\n      highlightKey: highlightKey\n    });\n    this.scrollMenuIntoView();\n    return highlightItem;\n  }; // scroll into focus item\n\n\n  Base.prototype.scrollMenuIntoView = function scrollMenuIntoView() {\n    var _this5 = this;\n\n    var prefix = this.props.prefix;\n    clearTimeout(this.highlightTimer);\n    this.highlightTimer = setTimeout(function () {\n      try {\n        var menuNode = findDOMNode(_this5.menuRef);\n        var itemNode = menuNode.querySelector('.' + prefix + 'select-menu-item.' + prefix + 'focused');\n        itemNode && itemNode.scrollIntoViewIfNeeded();\n      } catch (ex) {// I don't care...\n      }\n    });\n  };\n  /**\n   * render popup menu header\n   * @abstract\n   */\n\n\n  Base.prototype.renderMenuHeader = function renderMenuHeader() {\n    return null;\n  };\n\n  Base.prototype.handleSelect = function handleSelect() {};\n  /**\n   * render popup children\n   * @protected\n   * @param {object} props\n   */\n\n\n  Base.prototype.renderMenu = function renderMenu() {\n    var _classNames,\n        _this6 = this;\n\n    var _props3 = this.props,\n        prefix = _props3.prefix,\n        mode = _props3.mode,\n        autoWidth = _props3.autoWidth,\n        locale = _props3.locale,\n        notFoundContent = _props3.notFoundContent,\n        useVirtual = _props3.useVirtual;\n    var _state = this.state,\n        dataSource = _state.dataSource,\n        highlightKey = _state.highlightKey;\n    var value = this.state.value;\n    var selectedKeys = void 0;\n\n    if (isNull(value) || value.length === 0) {\n      selectedKeys = [];\n    } else if (isSingle(mode)) {\n      selectedKeys = [valueToSelectKey(value)];\n    } else {\n      selectedKeys = [].concat(value).map(function (n) {\n        return valueToSelectKey(n);\n      });\n    }\n\n    var children = this.renderMenuItem(dataSource);\n    var menuClassName = classNames((_classNames = {}, _classNames[prefix + 'select-menu'] = true, _classNames[prefix + 'select-menu-empty'] = !children || !children.length, _classNames));\n\n    if (!children || !children.length) {\n      children = React.createElement('span', {\n        className: prefix + 'select-menu-empty-content'\n      }, notFoundContent || locale.notFoundContent);\n    }\n\n    var menuProps = {\n      children: children,\n      style: autoWidth ? {\n        width: this.width\n      } : {\n        minWidth: this.width\n      },\n      selectedKeys: selectedKeys,\n      focusedKey: highlightKey,\n      focusable: false,\n      selectMode: isSingle(mode) ? 'single' : 'multiple',\n      onSelect: this.handleMenuSelect,\n      onItemClick: this.handleItemClick,\n      header: this.renderMenuHeader(),\n      onClick: this.handleMenuBodyClick,\n      onMouseDown: preventDefault,\n      className: menuClassName\n    };\n    return useVirtual && children.length ? React.createElement('div', {\n      className: prefix + 'select-menu-wrapper',\n      style: {\n        position: 'relative'\n      }\n    }, React.createElement(VirtualList, {\n      itemsRenderer: function itemsRenderer(items, _ref) {\n        return React.createElement(Menu, _extends({\n          ref: function ref(c) {\n            _ref(c);\n\n            _this6.menuRef = c;\n          }\n        }, menuProps), items);\n      }\n    }, children)) : React.createElement(Menu, menuProps);\n  };\n  /**\n   * render menu item\n   * @protected\n   * @param {Array} dataSource\n   */\n\n\n  Base.prototype.renderMenuItem = function renderMenuItem(dataSource) {\n    var _this7 = this;\n\n    var _props4 = this.props,\n        prefix = _props4.prefix,\n        itemRender = _props4.itemRender; // If it has.\n\n    var searchKey = void 0;\n\n    if (this.isAutoComplete) {\n      // In AutoComplete, value is the searchKey\n      searchKey = this.state.value;\n    } else {\n      searchKey = this.state.searchValue;\n    }\n\n    return dataSource.map(function (item, index) {\n      if (!item) {\n        return null;\n      }\n\n      if (Array.isArray(item.children)) {\n        return React.createElement(MenuGroup, {\n          key: index,\n          label: item.label\n        }, _this7.renderMenuItem(item.children));\n      } else {\n        var itemProps = {\n          key: item.value,\n          className: prefix + 'select-menu-item',\n          disabled: item.disabled\n        };\n\n        if (item.title) {\n          itemProps.title = item.title;\n        }\n\n        return React.createElement(MenuItem, itemProps, itemRender(item, searchKey));\n      }\n    });\n  };\n  /**\n   * 点击 arrow 或 label 的时候焦点切到 input 中\n   * @override\n   */\n\n\n  Base.prototype.focusInput = function focusInput() {\n    this.inputRef.focus();\n  };\n\n  Base.prototype.beforeOpen = function beforeOpen() {\n    var _state2 = this.state,\n        value = _state2.value,\n        highlightKey = _state2.highlightKey;\n\n    if (this.props.mode === 'single' && !value && !highlightKey) {\n      this.setFirstHightLightKeyForMenu();\n    }\n\n    this.syncWidth();\n  };\n\n  Base.prototype.beforeClose = function beforeClose() {};\n\n  Base.prototype.afterClose = function afterClose() {};\n\n  Base.prototype.render = function render(props) {\n    var _classNames2;\n\n    var prefix = props.prefix,\n        mode = props.mode,\n        popupProps = props.popupProps,\n        popupContainer = props.popupContainer,\n        popupClassName = props.popupClassName,\n        popupStyle = props.popupStyle,\n        popupContent = props.popupContent,\n        autoWidth = props.autoWidth,\n        canCloseByTrigger = props.canCloseByTrigger,\n        cache = props.cache;\n    var cls = classNames((_classNames2 = {}, _classNames2[prefix + 'select-auto-complete-menu'] = !popupContent && this.isAutoComplete, _classNames2[prefix + 'select-' + mode + '-menu'] = !popupContent && !!mode, _classNames2), popupClassName || popupProps.className);\n\n    var _props = _extends({\n      triggerType: 'click',\n      autoFocus: false,\n      cache: cache\n    }, popupProps, {\n      //beforeOpen node not mount, afterOpen too slow.\n      // from display:none to block, we may need to recompute width\n      beforeOpen: makeChain(this.beforeOpen, popupProps.beforeOpen),\n      beforeClose: makeChain(this.beforeClose, popupProps.beforeClose),\n      afterClose: makeChain(this.afterClose, popupProps.afterClose),\n      canCloseByTrigger: canCloseByTrigger,\n      visible: this.state.visible,\n      onVisibleChange: this.handleVisibleChange,\n      shouldUpdatePosition: true,\n      container: popupContainer || popupProps.container,\n      className: cls,\n      style: popupStyle || popupProps.style\n    });\n\n    return React.createElement(Popup, _extends({}, _props, {\n      trigger: this.renderSelect(),\n      ref: this.savePopupRef\n    }), popupContent ? React.createElement('div', {\n      className: prefix + 'select-popup-wrap',\n      style: autoWidth ? {\n        width: this.width\n      } : {}\n    }, popupContent) : this.renderMenu());\n  };\n\n  return Base;\n}(React.Component), _class.propTypes = {\n  prefix: PropTypes.string,\n\n  /**\n   * 选择器尺寸\n   */\n  size: PropTypes.oneOf(['small', 'medium', 'large']),\n  // 当前值，用于受控模式\n  value: PropTypes.any,\n  // to be override\n  // 初始化的默认值\n  defaultValue: PropTypes.any,\n  // to be override\n\n  /**\n   * 没有值的时候的占位符\n   */\n  placeholder: PropTypes.string,\n\n  /**\n   * 下拉菜单是否与选择器对齐\n   */\n  autoWidth: PropTypes.bool,\n\n  /**\n   * 自定义内联 label\n   */\n  label: PropTypes.node,\n\n  /**\n   * 是否有清除按钮\n   */\n  hasClear: PropTypes.bool,\n\n  /**\n   * 校验状态\n   */\n  state: PropTypes.oneOf(['error', 'loading']),\n\n  /**\n   * 是否只读，只读模式下可以展开弹层但不能选\n   */\n  readOnly: PropTypes.bool,\n\n  /**\n   * 是否禁用选择器\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * 当前弹层是否显示\n   */\n  visible: PropTypes.bool,\n\n  /**\n   * 弹层初始化是否显示\n   */\n  defaultVisible: PropTypes.bool,\n\n  /**\n   * 弹层显示或隐藏时触发的回调\n   * @param {Boolean} visible 弹层是否显示\n   */\n  onVisibleChange: PropTypes.func,\n\n  /**\n   * 弹层挂载的容器节点\n   */\n  popupContainer: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n\n  /**\n   * 弹层的 className\n   */\n  popupClassName: PropTypes.any,\n\n  /**\n   * 弹层的内联样式\n   */\n  popupStyle: PropTypes.object,\n\n  /**\n   * 添加到弹层上的属性\n   */\n  popupProps: PropTypes.object,\n\n  /**\n   * 自定义弹层的内容\n   */\n  popupContent: PropTypes.node,\n\n  /**\n   * 是否使用本地过滤，在数据源为远程的时候需要关闭此项\n   */\n  filterLocal: PropTypes.bool,\n\n  /**\n   * 本地过滤方法，返回一个 Boolean 值确定是否保留\n   */\n  filter: PropTypes.func,\n\n  /**\n   * 键盘上下键切换菜单高亮选项的回调\n   */\n  onToggleHighlightItem: PropTypes.func,\n\n  /**\n   * 是否开启虚拟滚动模式\n   */\n  useVirtual: PropTypes.bool,\n  // 自定义类名\n  className: PropTypes.any,\n  children: PropTypes.any,\n  dataSource: PropTypes.array,\n  itemRender: PropTypes.func,\n  mode: PropTypes.string,\n  notFoundContent: PropTypes.node,\n  locale: PropTypes.object,\n  rtl: PropTypes.bool\n}, _class.defaultProps = {\n  prefix: 'next-',\n  size: 'medium',\n  autoWidth: true,\n  onChange: noop,\n  onVisibleChange: noop,\n  onToggleHighlightItem: noop,\n  popupProps: {},\n  filterLocal: true,\n  filter: filter,\n  itemRender: function itemRender(item) {\n    return item.label || item.value;\n  },\n  locale: zhCN.Select\n}, _temp);\nBase.displayName = 'Base';\nexport { Base as default };","map":null,"metadata":{},"sourceType":"module"}