{"ast":null,"code":"import _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';\nimport _extends from 'babel-runtime/helpers/extends';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\n\nvar _class, _temp;\n\nimport React, { Component, Children, isValidElement, cloneElement } from 'react';\nimport PropTypes from 'prop-types';\nimport Select from '../select';\nimport Tree from '../tree';\nimport { normalizeToArray, getAllCheckedKeys, filterChildKey, filterParentKey, isDescendantOrSelf } from '../tree/view/util';\nimport { func, obj } from '../util';\n\nvar noop = function noop() {};\n\nvar TreeNode = Tree.Node;\nvar bindCtx = func.bindCtx;\nvar pickOthers = obj.pickOthers;\n/**\n * TreeSelect\n */\n\nvar TreeSelect = (_temp = _class = function (_Component) {\n  _inherits(TreeSelect, _Component);\n\n  function TreeSelect(props, context) {\n    _classCallCheck(this, TreeSelect);\n\n    var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));\n\n    var defaultVisible = props.defaultVisible,\n        visible = props.visible,\n        defaultValue = props.defaultValue,\n        value = props.value;\n    _this.state = {\n      visible: typeof visible === 'undefined' ? defaultVisible : visible,\n      value: normalizeToArray(typeof value === 'undefined' ? defaultValue : value),\n      searchedValue: '',\n      expandedKeys: [],\n      autoExpandParent: false\n    };\n    bindCtx(_this, ['handleSelect', 'handleCheck', 'handleSearch', 'handleSearchClear', 'handleVisibleChange', 'handleChange', 'handleRemove', 'handleExpand']);\n\n    _this.updateCache(props);\n\n    return _this;\n  }\n\n  TreeSelect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    this.updateCache(nextProps);\n    var st = {};\n\n    if ('value' in nextProps) {\n      st.value = normalizeToArray(nextProps.value);\n    }\n\n    if ('visible' in nextProps) {\n      st.visible = nextProps.visible;\n    }\n\n    if (Object.keys(st).length) {\n      this.setState(st);\n    }\n  };\n\n  TreeSelect.prototype.updateCache = function updateCache(props) {\n    var _this2 = this;\n\n    this._k2n = {};\n    this._p2n = {};\n    this._v2n = {};\n\n    if ('dataSource' in props) {\n      var loop = function loop(data) {\n        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '0';\n        return data.map(function (item, index) {\n          var value = item.value,\n              children = item.children;\n          var pos = prefix + '-' + index;\n          var key = item.key || pos;\n\n          var newItem = _extends({}, item, {\n            key: key,\n            pos: pos\n          });\n\n          if (children && children.length) {\n            newItem.children = loop(children, pos);\n          }\n\n          _this2._k2n[key] = _this2._p2n[pos] = _this2._v2n[value] = newItem;\n          return newItem;\n        });\n      };\n\n      loop(props.dataSource);\n    } else if ('children' in props) {\n      var _loop = function _loop(children) {\n        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '0';\n        return Children.map(children, function (node, index) {\n          var _node$props = node.props,\n              value = _node$props.value,\n              children = _node$props.children;\n          var pos = prefix + '-' + index;\n          var key = node.key || pos;\n\n          var newItem = _extends({}, node.props, {\n            key: key,\n            pos: pos\n          });\n\n          if (children && Children.count(children)) {\n            newItem.children = _loop(children, pos);\n          }\n\n          _this2._k2n[key] = _this2._p2n[pos] = _this2._v2n[value] = newItem;\n          return newItem;\n        });\n      };\n\n      _loop(props.children);\n    }\n  };\n\n  TreeSelect.prototype.getKeysByValue = function getKeysByValue(value) {\n    var _this3 = this;\n\n    return value.reduce(function (ret, v) {\n      var k = _this3._v2n[v] && _this3._v2n[v].key;\n\n      if (k) {\n        ret.push(k);\n      }\n\n      return ret;\n    }, []);\n  };\n\n  TreeSelect.prototype.getValueByKeys = function getValueByKeys(keys) {\n    var _this4 = this;\n\n    return keys.map(function (k) {\n      return _this4._k2n[k].value;\n    });\n  };\n\n  TreeSelect.prototype.getValueForSelect = function getValueForSelect(value) {\n    var treeCheckedStrategy = this.props.treeCheckedStrategy;\n    var keys = this.getKeysByValue(value);\n    keys = getAllCheckedKeys(keys, this._k2n, this._p2n);\n\n    switch (treeCheckedStrategy) {\n      case 'parent':\n        keys = filterChildKey(keys, this._k2n);\n        break;\n\n      case 'child':\n        keys = filterParentKey(keys, this._k2n);\n        break;\n\n      default:\n        break;\n    }\n\n    return this.getValueByKeys(keys);\n  };\n\n  TreeSelect.prototype.getData = function getData(value, forSelect) {\n    var _this5 = this;\n\n    return value.reduce(function (ret, v) {\n      var k = _this5._v2n[v] && _this5._v2n[v].key;\n\n      if (k) {\n        var _k2n$k = _this5._k2n[k],\n            label = _k2n$k.label,\n            pos = _k2n$k.pos,\n            disabled = _k2n$k.disabled,\n            checkboxDisabled = _k2n$k.checkboxDisabled;\n        var d = {\n          value: v,\n          label: label,\n          pos: pos\n        };\n\n        if (forSelect) {\n          d.disabled = disabled || checkboxDisabled;\n        } else {\n          d.key = k;\n        }\n\n        ret.push(d);\n      }\n\n      return ret;\n    }, []);\n  };\n\n  TreeSelect.prototype.handleVisibleChange = function handleVisibleChange(visible, type) {\n    if (!('visible' in this.props)) {\n      this.setState({\n        visible: visible\n      });\n    }\n\n    this.props.onVisibleChange(visible, type);\n  };\n\n  TreeSelect.prototype.handleSelect = function handleSelect(selectedKeys, extra) {\n    var _props = this.props,\n        multiple = _props.multiple,\n        onChange = _props.onChange;\n    var selected = extra.selected;\n\n    if (multiple || selected) {\n      var value = this.getValueByKeys(selectedKeys);\n\n      if (!('value' in this.props)) {\n        this.setState({\n          value: value\n        });\n      }\n\n      if (!multiple) {\n        this.handleVisibleChange(false, 'fromTree');\n      }\n\n      var data = this.getData(value);\n      multiple ? onChange(value, data) : onChange(value[0], data[0]);\n    } else {\n      this.handleVisibleChange(false, 'fromTree');\n    }\n  };\n\n  TreeSelect.prototype.handleCheck = function handleCheck(checkedKeys) {\n    var onChange = this.props.onChange;\n    var value = this.getValueByKeys(checkedKeys);\n\n    if (!('value' in this.props)) {\n      this.setState({\n        value: value\n      });\n    }\n\n    onChange(value, this.getData(value));\n  };\n\n  TreeSelect.prototype.handleRemove = function handleRemove(removedItem) {\n    var _this6 = this;\n\n    var removedValue = removedItem.value;\n    var _props2 = this.props,\n        treeCheckable = _props2.treeCheckable,\n        treeCheckStrictly = _props2.treeCheckStrictly,\n        treeCheckedStrategy = _props2.treeCheckedStrategy,\n        onChange = _props2.onChange;\n    var value = void 0;\n\n    if (treeCheckable && !treeCheckStrictly && treeCheckedStrategy === 'all') {\n      var removedPos = this._v2n[removedValue].pos;\n      value = this.state.value.filter(function (v) {\n        var p = _this6._v2n[v].pos;\n        return !isDescendantOrSelf(removedPos, p);\n      });\n      var nums = removedPos.split('-');\n\n      for (var i = nums.length; i > 2; i--) {\n        var parentPos = nums.slice(0, i - 1).join('-');\n        var parentValue = this._p2n[parentPos].value;\n        var parentIndex = value.indexOf(parentValue);\n\n        if (parentIndex > -1) {\n          value.splice(parentIndex, 1);\n        } else {\n          break;\n        }\n      }\n    } else {\n      value = this.state.value.filter(function (v) {\n        return v !== removedValue;\n      });\n    }\n\n    if (!('value' in this.props)) {\n      this.setState({\n        value: value\n      });\n    }\n\n    var data = this.getData(value);\n    onChange(value, data);\n  };\n\n  TreeSelect.prototype.handleSearch = function handleSearch(searchedValue) {\n    var _this7 = this;\n\n    var searchedKeys = [];\n    var retainedKeys = [];\n    Object.keys(this._k2n).forEach(function (k) {\n      var _k2n$k2 = _this7._k2n[k],\n          label = _k2n$k2.label,\n          pos = _k2n$k2.pos;\n\n      if (_this7.isSearched(label, searchedValue)) {\n        searchedKeys.push(k);\n        var posArr = pos.split('-');\n        posArr.forEach(function (n, i) {\n          if (i > 0) {\n            var p = posArr.slice(0, i + 1).join('-');\n            var kk = _this7._p2n[p].key;\n\n            if (retainedKeys.indexOf(kk) === -1) {\n              retainedKeys.push(kk);\n            }\n          }\n        });\n      }\n    });\n    this.setState({\n      searchedValue: searchedValue,\n      expandedKeys: searchedKeys,\n      autoExpandParent: true\n    });\n    this.searchedKeys = searchedKeys;\n    this.retainedKeys = retainedKeys;\n    this.props.onSearch(searchedValue);\n  };\n\n  TreeSelect.prototype.handleSearchClear = function handleSearchClear(triggerType) {\n    this.setState({\n      searchedValue: '',\n      expandedKeys: []\n    });\n    this.props.onSearchClear(triggerType);\n  };\n\n  TreeSelect.prototype.handleExpand = function handleExpand(expandedKeys) {\n    this.setState({\n      expandedKeys: expandedKeys,\n      autoExpandParent: false\n    });\n  };\n\n  TreeSelect.prototype.handleChange = function handleChange() {\n    // 单选时点击清空按钮\n    var _props3 = this.props,\n        hasClear = _props3.hasClear,\n        multiple = _props3.multiple,\n        treeCheckable = _props3.treeCheckable;\n\n    if (hasClear && (!multiple || !treeCheckable)) {\n      if (!('value' in this.props)) {\n        this.setState({\n          value: []\n        });\n      }\n\n      this.props.onChange(null, null);\n    }\n  };\n\n  TreeSelect.prototype.isSearched = function isSearched(label, searchedValue) {\n    var labelString = '';\n\n    var loop = function loop(arg) {\n      if (isValidElement(arg) && arg.props.children) {\n        Children.forEach(arg.props.children, loop);\n      } else if (typeof arg === 'string') {\n        labelString += arg;\n      }\n    };\n\n    loop(label);\n\n    if (labelString.length >= searchedValue.length && labelString.indexOf(searchedValue) > -1) {\n      return true;\n    }\n\n    return false;\n  };\n\n  TreeSelect.prototype.searchNodes = function searchNodes(children) {\n    var _this8 = this;\n\n    var loop = function loop(children) {\n      var retainedNodes = [];\n      Children.forEach(children, function (child) {\n        if (_this8.searchedKeys.indexOf(child.key) > -1) {\n          retainedNodes.push(child);\n        } else if (_this8.retainedKeys.indexOf(child.key) > -1) {\n          var retainedNode = child.props.children ? cloneElement(child, {}, loop(child.props.children)) : child;\n          retainedNodes.push(retainedNode);\n        } else {\n          var hideNode = cloneElement(child, {\n            style: {\n              display: 'none'\n            }\n          });\n          retainedNodes.push(hideNode);\n        }\n      });\n      return retainedNodes;\n    };\n\n    return loop(children);\n  };\n\n  TreeSelect.prototype.createNodesByData = function createNodesByData(data, searching) {\n    var _this9 = this;\n\n    var loop = function loop(data, isParentMatched) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '0';\n      var retainedNodes = [];\n      data.forEach(function (item, index) {\n        var children = item.children,\n            others = _objectWithoutProperties(item, ['children']);\n\n        var pos = prefix + '-' + index;\n        var key = _this9._p2n[pos].key;\n\n        var addNode = function addNode(isParentMatched, hide) {\n          if (hide) {\n            others.style = {\n              display: 'none'\n            };\n          }\n\n          retainedNodes.push(React.createElement(TreeNode, _extends({}, others, {\n            key: key\n          }), children && children.length ? loop(children, isParentMatched, pos) : null));\n        };\n\n        if (searching) {\n          if (_this9.searchedKeys.indexOf(key) > -1 || isParentMatched) {\n            addNode(true);\n          } else if (_this9.retainedKeys.indexOf(key) > -1) {\n            addNode(false);\n          } else {\n            addNode(false, true);\n          }\n        } else {\n          addNode();\n        }\n      });\n      return retainedNodes;\n    };\n\n    return loop(data, false);\n  };\n\n  TreeSelect.prototype.renderPopupContent = function renderPopupContent() {\n    var _this10 = this;\n\n    var prefix = this.props.prefix;\n    var treeSelectPrefix = prefix + 'tree-select-';\n\n    if (!this.state.visible) {\n      return React.createElement('div', {\n        className: treeSelectPrefix + 'dropdown'\n      });\n    }\n\n    var _props4 = this.props,\n        multiple = _props4.multiple,\n        treeCheckable = _props4.treeCheckable,\n        treeCheckStrictly = _props4.treeCheckStrictly,\n        treeCheckedStrategy = _props4.treeCheckedStrategy,\n        treeDefaultExpandAll = _props4.treeDefaultExpandAll,\n        treeDefaultExpandedKeys = _props4.treeDefaultExpandedKeys,\n        treeLoadData = _props4.treeLoadData,\n        customTreeProps = _props4.treeProps,\n        showSearch = _props4.showSearch,\n        dataSource = _props4.dataSource,\n        children = _props4.children,\n        readOnly = _props4.readOnly,\n        notFoundContent = _props4.notFoundContent;\n    var _state = this.state,\n        value = _state.value,\n        searchedValue = _state.searchedValue,\n        expandedKeys = _state.expandedKeys,\n        autoExpandParent = _state.autoExpandParent;\n    var treeProps = {\n      multiple: multiple,\n      loadData: treeLoadData,\n      defaultExpandAll: treeDefaultExpandAll,\n      defaultExpandedKeys: treeDefaultExpandedKeys\n    };\n    var keys = this.getKeysByValue(value);\n\n    if (treeCheckable) {\n      treeProps.checkable = treeCheckable;\n      treeProps.checkStrictly = treeCheckStrictly;\n      treeProps.checkedStrategy = treeCheckStrictly ? 'all' : treeCheckedStrategy;\n      treeProps.checkedKeys = keys;\n\n      if (!readOnly) {\n        treeProps.onCheck = this.handleCheck;\n      }\n    } else {\n      treeProps.selectedKeys = keys;\n\n      if (!readOnly) {\n        treeProps.onSelect = this.handleSelect;\n      }\n    }\n\n    var notFound = false;\n    var newChildren = void 0;\n\n    if (showSearch && searchedValue) {\n      treeProps.expandedKeys = expandedKeys;\n      treeProps.autoExpandParent = autoExpandParent;\n      treeProps.onExpand = this.handleExpand;\n\n      treeProps.filterTreeNode = function (node) {\n        return _this10.searchedKeys.indexOf(node.props.eventKey) > -1;\n      };\n\n      if (this.searchedKeys.length) {\n        newChildren = dataSource ? this.createNodesByData(dataSource, true) : this.searchNodes(children);\n      } else {\n        notFound = true;\n      }\n    } else {\n      // eslint-disable-next-line\n      if (dataSource) {\n        if (dataSource.length) {\n          newChildren = this.createNodesByData(dataSource);\n        } else {\n          notFound = true;\n        }\n      } else {\n        // eslint-disable-next-line\n        if (Children.count(children)) {\n          newChildren = children;\n        } else {\n          notFound = true;\n        }\n      }\n    }\n\n    return React.createElement('div', {\n      className: treeSelectPrefix + 'dropdown'\n    }, notFound ? React.createElement('div', {\n      className: treeSelectPrefix + 'not-found'\n    }, notFoundContent) : React.createElement(Tree, _extends({}, customTreeProps, treeProps), newChildren));\n  };\n\n  TreeSelect.prototype.render = function render() {\n    var _props5 = this.props,\n        prefix = _props5.prefix,\n        size = _props5.size,\n        placeholder = _props5.placeholder,\n        disabled = _props5.disabled,\n        hasArrow = _props5.hasArrow,\n        hasBorder = _props5.hasBorder,\n        hasClear = _props5.hasClear,\n        label = _props5.label,\n        readOnly = _props5.readOnly,\n        autoWidth = _props5.autoWidth,\n        popupStyle = _props5.popupStyle,\n        popupClassName = _props5.popupClassName,\n        showSearch = _props5.showSearch,\n        multiple = _props5.multiple,\n        treeCheckable = _props5.treeCheckable,\n        treeCheckStrictly = _props5.treeCheckStrictly,\n        className = _props5.className,\n        popupContainer = _props5.popupContainer,\n        popupProps = _props5.popupProps;\n    var others = pickOthers(Object.keys(TreeSelect.propTypes), this.props);\n    var _state2 = this.state,\n        value = _state2.value,\n        visible = _state2.visible;\n    var valueForSelect = treeCheckable && !treeCheckStrictly ? this.getValueForSelect(value) : value;\n    var data = this.getData(valueForSelect, true);\n\n    if (!multiple && !treeCheckable) {\n      data = data[0];\n    }\n\n    return React.createElement(Select, _extends({\n      prefix: prefix,\n      className: className,\n      size: size,\n      hasBorder: hasBorder,\n      hasArrow: hasArrow,\n      hasClear: hasClear,\n      placeholder: placeholder,\n      disabled: disabled,\n      autoWidth: autoWidth,\n      label: label,\n      readOnly: readOnly,\n      mode: treeCheckable || multiple ? 'multiple' : 'single',\n      value: data,\n      onRemove: this.handleRemove,\n      onChange: this.handleChange,\n      visible: visible,\n      onVisibleChange: this.handleVisibleChange,\n      showSearch: showSearch,\n      onSearch: this.handleSearch,\n      onSearchClear: this.handleSearchClear,\n      popupContent: this.renderPopupContent(),\n      popupContainer: popupContainer,\n      popupStyle: popupStyle,\n      popupClassName: popupClassName,\n      popupProps: popupProps\n    }, others));\n  };\n\n  return TreeSelect;\n}(Component), _class.propTypes = {\n  prefix: PropTypes.string,\n  pure: PropTypes.bool,\n  className: PropTypes.string,\n\n  /**\n   * 树节点\n   */\n  children: PropTypes.node,\n\n  /**\n   * 选择框大小\n   */\n  size: PropTypes.oneOf(['small', 'medium', 'large']),\n\n  /**\n   * 选择框占位符\n   */\n  placeholder: PropTypes.string,\n\n  /**\n   * 是否禁用\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * 是否有下拉箭头\n   */\n  hasArrow: PropTypes.bool,\n\n  /**\n   * 是否有边框\n   */\n  hasBorder: PropTypes.bool,\n\n  /**\n   * 是否有清空按钮\n   */\n  hasClear: PropTypes.bool,\n\n  /**\n   * 自定义内联 label\n   */\n  label: PropTypes.node,\n\n  /**\n   * 是否只读，只读模式下可以展开弹层但不能选择\n   */\n  readOnly: PropTypes.bool,\n\n  /**\n   * 下拉框是否与选择器对齐\n   */\n  autoWidth: PropTypes.bool,\n\n  /**\n   * 数据源，该属性优先级高于 children\n   */\n  dataSource: PropTypes.arrayOf(PropTypes.object),\n\n  /**\n   * （受控）当前值\n   */\n  value: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n\n  /**\n   * （非受控）默认值\n   */\n  defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n\n  /**\n   * 选中值改变时触发的回调函数\n   * @param {String|Array} value 选中的值，单选时返回单个值，多选时返回数组\n   * @param {Object|Array} data 选中的数据，包括 value, label, pos, key属性，单选时返回单个值，多选时返回数组，父子节点选中关联时，同时选中，只返回父节点\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * 是否显示搜索框\n   */\n  showSearch: PropTypes.bool,\n\n  /**\n   * 在搜索框中输入时触发的回调函数\n   * @param {String} keyword 输入的关键字\n   */\n  onSearch: PropTypes.func,\n  onSearchClear: PropTypes.func,\n\n  /**\n   * 无数据时显示内容\n   */\n  notFoundContent: PropTypes.node,\n\n  /**\n   * 是否支持多选\n   */\n  multiple: PropTypes.bool,\n\n  /**\n   * 下拉框中的树是否支持勾选节点的复选框\n   */\n  treeCheckable: PropTypes.bool,\n\n  /**\n   * 下拉框中的树勾选节点复选框是否完全受控（父子节点选中状态不再关联）\n   */\n  treeCheckStrictly: PropTypes.bool,\n\n  /**\n   * 定义选中时回填的方式\n   * @enumdesc 返回所有选中的节点, 父子节点都选中时只返回父节点, 父子节点都选中时只返回子节点\n   */\n  treeCheckedStrategy: PropTypes.oneOf(['all', 'parent', 'child']),\n\n  /**\n   * 下拉框中的树是否默认展开所有节点\n   */\n  treeDefaultExpandAll: PropTypes.bool,\n\n  /**\n   * 下拉框中的树默认展开节点key的数组\n   */\n  treeDefaultExpandedKeys: PropTypes.arrayOf(PropTypes.string),\n\n  /**\n   * 下拉框中的树异步加载数据的函数，使用请参考[Tree的异步加载数据Demo](https://fusion.design/component/tree)\n   * @param {ReactElement} node 被点击展开的节点\n   */\n  treeLoadData: PropTypes.func,\n\n  /**\n   * 透传到 Tree 的属性对象\n   */\n  treeProps: PropTypes.object,\n\n  /**\n   * 初始下拉框是否显示\n   */\n  defaultVisible: PropTypes.bool,\n\n  /**\n   * 当前下拉框是否显示\n   */\n  visible: PropTypes.bool,\n\n  /**\n   * 下拉框显示或关闭时触发事件的回调函数\n   * @param {Boolean} visible 是否显示\n   * @param {String} type 触发显示关闭的操作类型\n   */\n  onVisibleChange: PropTypes.func,\n\n  /**\n   * 下拉框自定义样式对象\n   */\n  popupStyle: PropTypes.object,\n\n  /**\n   * 下拉框样式自定义类名\n   */\n  popupClassName: PropTypes.string,\n\n  /**\n   * 下拉框挂载的容器节点\n   */\n  popupContainer: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n\n  /**\n   * 透传到 Popup 的属性对象\n   */\n  popupProps: PropTypes.object\n}, _class.defaultProps = {\n  prefix: 'next-',\n  pure: false,\n  size: 'medium',\n  disabled: false,\n  hasArrow: true,\n  hasBorder: true,\n  hasClear: false,\n  autoWidth: true,\n  defaultValue: null,\n  onChange: noop,\n  showSearch: false,\n  onSearch: noop,\n  onSearchClear: noop,\n  notFoundContent: 'Not Found',\n  multiple: false,\n  treeCheckable: false,\n  treeCheckStrictly: false,\n  treeCheckedStrategy: 'parent',\n  treeDefaultExpandAll: false,\n  treeDefaultExpandedKeys: [],\n  treeProps: {},\n  defaultVisible: false,\n  onVisibleChange: noop\n}, _temp);\nTreeSelect.displayName = 'TreeSelect';\nexport { TreeSelect as default };\nTreeSelect.Node = TreeNode;","map":null,"metadata":{},"sourceType":"module"}