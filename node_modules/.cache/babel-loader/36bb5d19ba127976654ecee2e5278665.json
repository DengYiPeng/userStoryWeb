{"ast":null,"code":"import _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';\nimport _extends from 'babel-runtime/helpers/extends';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\n\nvar _class, _temp;\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classnames from 'classnames';\nimport shallowElementEquals from 'shallow-element-equals';\nimport Loading from '../loading';\nimport zhCN from '../locale/zh-cn';\nimport { log, obj } from '../util';\nimport BodyComponent from './base/body';\nimport HeaderComponent from './base/header';\nimport WrapperComponent from './base/wrapper';\nimport RowComponent from './base/row';\nimport CellComponent from './base/cell';\nimport FilterComponent from './base/filter';\nimport SortComponent from './base/sort';\nimport Column from './column';\nimport ColumnGroup from './column-group';\n\nvar Children = React.Children,\n    noop = function noop() {}; //<Table>\n//    <Table.Column/>\n//    <Table.ColumnGroup>\n//      <Table.Column/>\n//      <Table.Column/>\n//    </Table.ColumnGroup>\n//</Table>\n\n/** Table */\n\n\nvar Table = (_temp = _class = function (_React$Component) {\n  _inherits(Table, _React$Component);\n\n  function Table(props, context) {\n    _classCallCheck(this, Table);\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\n\n    _this.state = {\n      sort: _this.props.sort || {}\n    };\n\n    _this.onSort = function (dataIndex, order, sort) {\n      if (typeof _this.props.sort === 'undefined') {\n        _this.setState({\n          sort: sort\n        }, function () {\n          _this.props.onSort(dataIndex, order, sort);\n        });\n      } else {\n        _this.props.onSort(dataIndex, order, sort);\n      }\n    };\n\n    _this.onFilter = function (filterParams) {\n      _this.props.onFilter(filterParams);\n    };\n\n    _this.onResizeChange = function (dataIndex, value) {\n      _this.props.onResizeChange(dataIndex, value);\n    };\n\n    _this.getWrapperRef = function (wrapper) {\n      if (!wrapper) {\n        return _this.wrapper;\n      }\n\n      _this.wrapper = wrapper;\n    };\n\n    _this.getAffixRef = function (affixRef) {\n      if (!affixRef) {\n        return _this.affixRef;\n      }\n\n      _this.affixRef = affixRef;\n    };\n\n    _this.getHeaderCellRef = function (i, j, cell) {\n      var cellRef = 'header_cell_' + i + '_' + j;\n\n      if (!cell) {\n        return _this[cellRef];\n      }\n\n      _this[cellRef] = cell;\n    };\n\n    _this.getRowRef = function (i, row) {\n      var rowRef = 'row_' + i;\n\n      if (!row) {\n        return _this[rowRef];\n      }\n\n      _this[rowRef] = row;\n    };\n\n    _this.getCellRef = function (i, j, cell) {\n      var cellRef = 'cell_' + i + '_' + j;\n\n      if (!cell) {\n        return _this[cellRef];\n      }\n\n      _this[cellRef] = cell;\n    };\n\n    var _this$context = _this.context,\n        getTableInstance = _this$context.getTableInstance,\n        getTableInstanceForVirtual = _this$context.getTableInstanceForVirtual;\n    getTableInstance && getTableInstance(props.lockType, _this);\n    getTableInstanceForVirtual && getTableInstanceForVirtual(props.lockType, _this);\n    _this.notRenderCellIndex = [];\n    return _this;\n  }\n\n  Table.prototype.getChildContext = function getChildContext() {\n    return {\n      notRenderCellIndex: this.notRenderCellIndex,\n      lockType: this.props.lockType\n    };\n  };\n\n  Table.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    if (typeof this.props.sort !== 'undefined') {\n      this.setState({\n        sort: nextProps.sort\n      });\n    }\n  };\n\n  Table.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState, nextContext) {\n    if (nextProps.pure) {\n      var isEqual = shallowElementEquals(nextProps, this.props) && obj.shallowEqual(nextState, this.state) && obj.shallowEqual(nextContext, this.context);\n      return !isEqual;\n    }\n\n    return true;\n  };\n\n  Table.prototype.componentWillUpdate = function componentWillUpdate() {\n    this.notRenderCellIndex = [];\n  };\n\n  Table.prototype.normalizeChildrenState = function normalizeChildrenState(props) {\n    var columns = props.columns;\n\n    if (props.children) {\n      columns = this.normalizeChildren(props);\n    }\n\n    return this.fetchInfoFromBinaryChildren(columns);\n  }; // 将React结构化数据提取props转换成数组\n\n\n  Table.prototype.normalizeChildren = function normalizeChildren(props) {\n    var columns = props.columns;\n\n    var getChildren = function getChildren(children) {\n      var ret = [];\n      Children.forEach(children, function (child) {\n        if (child) {\n          var _props = _extends({}, child.props);\n\n          if (!(child && typeof child.type === 'function' && (child.type._typeMark === 'column' || child.type._typeMark === 'columnGroup'))) {\n            log.warning('Use <Table.Column/>, <Table.ColumnGroup/> as child.');\n          }\n\n          ret.push(_props);\n\n          if (child.props.children) {\n            _props.children = getChildren(child.props.children);\n          }\n        }\n      });\n      return ret;\n    };\n\n    if (props.children) {\n      columns = getChildren(props.children);\n    }\n\n    return columns;\n  };\n\n  Table.prototype.fetchInfoFromBinaryChildren = function fetchInfoFromBinaryChildren(children) {\n    var hasGroupHeader = false;\n\n    var flatChildren = [],\n        groupChildren = [],\n        getChildren = function getChildren(propsChildren, level) {\n      groupChildren[level] = groupChildren[level] || [];\n      propsChildren.forEach(function (child) {\n        if (child.children) {\n          hasGroupHeader = true;\n          getChildren(child.children, level + 1);\n        } else {\n          flatChildren.push(child);\n        }\n\n        groupChildren[level].push(child);\n      });\n    },\n        getColSpan = function getColSpan(children, colSpan) {\n      colSpan = colSpan || 0;\n      children.forEach(function (child) {\n        if (child.children) {\n          colSpan = getColSpan(child.children, colSpan);\n        } else {\n          colSpan += 1;\n        }\n      });\n      return colSpan;\n    };\n\n    getChildren(children, 0);\n    groupChildren.forEach(function (groupChild, i) {\n      groupChild.forEach(function (child, j) {\n        var colSpan = void 0;\n        var children = child.children;\n\n        if (children) {\n          colSpan = getColSpan(children);\n          child.colSpan = colSpan;\n          groupChildren[i][j] = child;\n        }\n      });\n    });\n    return {\n      flatChildren: flatChildren,\n      groupChildren: groupChildren,\n      hasGroupHeader: hasGroupHeader\n    };\n  };\n\n  Table.prototype.renderColGroup = function renderColGroup(flatChildren) {\n    var cols = flatChildren.map(function (col, index) {\n      var width = col.width;\n      var style = {};\n\n      if (width) {\n        style = {\n          width: width\n        };\n      }\n\n      return React.createElement('col', {\n        style: style,\n        key: index\n      });\n    });\n    return React.createElement('colgroup', {\n      key: 'table-colgroup'\n    }, cols);\n  }; // 通过头部和扁平的结构渲染表格\n\n\n  Table.prototype.renderTable = function renderTable(groupChildren, flatChildren) {\n    if (flatChildren.length || !flatChildren.length && !this.props.lockType) {\n      var _props2 = this.props,\n          hasHeader = _props2.hasHeader,\n          components = _props2.components,\n          prefix = _props2.prefix,\n          wrapperContent = _props2.wrapperContent,\n          filterParams = _props2.filterParams,\n          locale = _props2.locale,\n          dataSource = _props2.dataSource,\n          emptyContent = _props2.emptyContent,\n          loading = _props2.loading,\n          getCellProps = _props2.getCellProps,\n          primaryKey = _props2.primaryKey,\n          getRowProps = _props2.getRowProps,\n          onRowClick = _props2.onRowClick,\n          onRowMouseEnter = _props2.onRowMouseEnter,\n          onRowMouseLeave = _props2.onRowMouseLeave,\n          pure = _props2.pure;\n      var sort = this.state.sort;\n      var _components$Header = components.Header,\n          Header = _components$Header === undefined ? HeaderComponent : _components$Header,\n          _components$Wrapper = components.Wrapper,\n          Wrapper = _components$Wrapper === undefined ? WrapperComponent : _components$Wrapper,\n          _components$Body = components.Body,\n          Body = _components$Body === undefined ? BodyComponent : _components$Body;\n      var colGroup = this.renderColGroup(flatChildren);\n      return React.createElement(Wrapper, {\n        colGroup: colGroup,\n        ref: this.getWrapperRef,\n        prefix: prefix\n      }, hasHeader ? React.createElement(Header, {\n        prefix: prefix,\n        pure: pure,\n        affixRef: this.getAffixRef,\n        colGroup: colGroup,\n        className: prefix + 'table-header',\n        filterParams: filterParams,\n        columns: groupChildren,\n        locale: locale,\n        headerCellRef: this.getHeaderCellRef,\n        components: components,\n        onFilter: this.onFilter,\n        sort: sort,\n        onResizeChange: this.onResizeChange,\n        onSort: this.onSort\n      }) : null, React.createElement(Body, {\n        prefix: prefix,\n        pure: pure,\n        colGroup: colGroup,\n        className: prefix + 'table-body',\n        components: components,\n        loading: loading,\n        emptyContent: emptyContent,\n        getCellProps: getCellProps,\n        primaryKey: primaryKey,\n        getRowProps: getRowProps,\n        columns: flatChildren,\n        rowRef: this.getRowRef,\n        cellRef: this.getCellRef,\n        onRowClick: onRowClick,\n        onRowMouseEnter: onRowMouseEnter,\n        onRowMouseLeave: onRowMouseLeave,\n        dataSource: dataSource,\n        locale: locale\n      }), wrapperContent);\n    } else {\n      return null;\n    }\n  };\n\n  Table.prototype.render = function render() {\n    var _classnames;\n\n    var ret = this.normalizeChildrenState(this.props);\n    this.groupChildren = ret.groupChildren;\n    this.flatChildren = ret.flatChildren;\n    /* eslint-disable no-unused-vars, prefer-const */\n\n    var table = this.renderTable(ret.groupChildren, ret.flatChildren),\n        _props3 = this.props,\n        className = _props3.className,\n        hasBorder = _props3.hasBorder,\n        isZebra = _props3.isZebra,\n        loading = _props3.loading,\n        hasHeader = _props3.hasHeader,\n        prefix = _props3.prefix,\n        dataSource = _props3.dataSource,\n        entireDataSource = _props3.entireDataSource,\n        onSort = _props3.onSort,\n        onResizeChange = _props3.onResizeChange,\n        onRowClick = _props3.onRowClick,\n        onRowMouseEnter = _props3.onRowMouseEnter,\n        onRowMouseLeave = _props3.onRowMouseLeave,\n        onFilter = _props3.onFilter,\n        getRowProps = _props3.getRowProps,\n        getCellProps = _props3.getCellProps,\n        primaryKey = _props3.primaryKey,\n        components = _props3.components,\n        wrapperContent = _props3.wrapperContent,\n        lockType = _props3.lockType,\n        locale = _props3.locale,\n        refs = _props3.refs,\n        pure = _props3.pure,\n        rtl = _props3.rtl,\n        emptyContent = _props3.emptyContent,\n        filterParams = _props3.filterParams,\n        _props3$loadingCompon = _props3.loadingComponent,\n        LoadingComponent = _props3$loadingCompon === undefined ? Loading : _props3$loadingCompon,\n        others = _objectWithoutProperties(_props3, ['className', 'hasBorder', 'isZebra', 'loading', 'hasHeader', 'prefix', 'dataSource', 'entireDataSource', 'onSort', 'onResizeChange', 'onRowClick', 'onRowMouseEnter', 'onRowMouseLeave', 'onFilter', 'getRowProps', 'getCellProps', 'primaryKey', 'components', 'wrapperContent', 'lockType', 'locale', 'refs', 'pure', 'rtl', 'emptyContent', 'filterParams', 'loadingComponent']),\n        cls = classnames((_classnames = {}, _classnames[prefix + 'table'] = true, _classnames['only-bottom-border'] = !hasBorder, _classnames['no-header'] = !hasHeader, _classnames.zebra = isZebra, _classnames[className] = className, _classnames));\n\n    if (rtl) {\n      others.dir = 'rtl';\n    }\n\n    var content = React.createElement('div', _extends({\n      className: cls\n    }, others), table);\n\n    if (loading) {\n      var loadingClassName = prefix + 'table-loading';\n      return React.createElement(LoadingComponent, {\n        className: loadingClassName\n      }, content);\n    }\n\n    return content;\n  };\n\n  return Table;\n}(React.Component), _class.Column = Column, _class.ColumnGroup = ColumnGroup, _class.Header = HeaderComponent, _class.Body = BodyComponent, _class.Wrapper = WrapperComponent, _class.Row = RowComponent, _class.Cell = CellComponent, _class.Filter = FilterComponent, _class.Sort = SortComponent, _class.propTypes = {\n  /**\n   * 样式类名的品牌前缀\n   */\n  prefix: PropTypes.string,\n  pure: PropTypes.bool,\n  rtl: PropTypes.bool,\n\n  /**\n   * 自定义类名\n   */\n  className: PropTypes.string,\n\n  /**\n   * 自定义内联样式\n   */\n  style: PropTypes.object,\n\n  /**\n   * 表格展示的数据源\n   */\n  dataSource: PropTypes.array,\n  entireDataSource: PropTypes.array,\n\n  /**\n   * 点击表格每一行触发的事件\n   * @param {Object} record 该行所对应的数据\n   * @param {Number} index 该行所对应的序列\n   * @param {Event} e DOM事件对象\n   */\n  onRowClick: PropTypes.func,\n\n  /**\n   * 悬浮在表格每一行的时候触发的事件\n   * @param {Object} record 该行所对应的数据\n   * @param {Number} index 该行所对应的序列\n   * @param {Event} e DOM事件对象\n   */\n  onRowMouseEnter: PropTypes.func,\n\n  /**\n   * 离开表格每一行的时候触发的事件\n   * @param {Object} record 该行所对应的数据\n   * @param {Number} index 该行所对应的序列\n   * @param {Event} e DOM事件对象\n   */\n  onRowMouseLeave: PropTypes.func,\n\n  /**\n   * 点击列排序触发的事件\n   * @param {String} dataIndex 指定的排序的字段\n   * @param {String} order 排序对应的顺序, 有`desc`和`asc`两种\n   */\n  onSort: PropTypes.func,\n\n  /**\n   * 点击过滤确认按钮触发的事件\n   * @param {Object} filterParams 过滤的字段信息\n   */\n  onFilter: PropTypes.func,\n\n  /**\n   * 重设列尺寸的时候触发的事件\n   * @param {String} dataIndex 指定重设的字段\n   * @param {Number} value 列宽变动的数值\n   */\n  onResizeChange: PropTypes.func,\n\n  /**\n   * 设置每一行的属性，如果返回值和其他针对行操作的属性冲突则无效。\n   * @param {Object} record 该行所对应的数据\n   * @param {Number} index 该行所对应的序列\n   * @returns {Object} 需要设置的行属性\n   */\n  getRowProps: PropTypes.func,\n\n  /**\n   * 设置单元格的属性，通过该属性可以进行合并单元格\n   * @param {Number} rowIndex 该行所对应的序列\n   * @param {Number} colIndex 该列所对应的序列\n   * @param {String} dataIndex 该列所对应的字段名称\n   * @param {Object} record 该行对应的记录\n   * @returns {Object} 返回td元素的所支持的属性对象\n   */\n  getCellProps: PropTypes.func,\n\n  /**\n   * 表格是否具有边框\n   */\n  hasBorder: PropTypes.bool,\n\n  /**\n   * 表格是否具有头部\n   */\n  hasHeader: PropTypes.bool,\n\n  /**\n   * 表格是否是斑马线\n   */\n  isZebra: PropTypes.bool,\n\n  /**\n   * 表格是否在加载中\n   */\n  loading: PropTypes.bool,\n\n  /**\n   * 自定义 Loading 组件\n   * @type {Function}\n   */\n  loadingComponent: PropTypes.func,\n\n  /**\n   * 当前过滤的的keys,使用此属性可以控制表格的头部的过滤选项中哪个菜单被选中,格式为 {dataIndex: {selectedKeys:[]}}\n   * 示例:\n   * 假设要控制dataIndex为id的列的过滤菜单中key为one的菜单项选中\n   * `<Table filterParams={{id: {selectedKeys: ['one']}}}/>`\n   */\n  filterParams: PropTypes.object,\n\n  /**\n   * 当前排序的字段,使用此属性可以控制表格的字段的排序,格式为{dataIndex: 'asc'}\n   */\n  sort: PropTypes.object,\n\n  /**\n   * 自定义国际化文案对象\n   * @property {String} ok 过滤器中确认按钮文案\n   * @property {String} reset 过滤器中重置按钮文案\n   * @property {String} empty 没有数据情况下 table内的文案\n   * @property {String} asc 排序升序状态下的文案\n   * @property {String} desc 排序将序状态下的文案\n   * @property {String} expanded 可折叠行，展开状态下的文案\n   * @property {String} folded 可折叠行，折叠状态下的文案\n   * @property {String} filter 过滤器文案\n   * @property {String} selectAll header里全选的按钮文案\n   */\n  locale: PropTypes.object,\n  components: PropTypes.object,\n  columns: PropTypes.array,\n\n  /**\n   * 设置数据为空的时候的表格内容展现\n   */\n  emptyContent: PropTypes.node,\n\n  /**\n   * dataSource当中数据的主键，如果给定的数据源中的属性不包含该主键，会造成选择状态全部选中\n   */\n  primaryKey: PropTypes.string,\n  lockType: PropTypes.oneOf(['left', 'right']),\n  wrapperContent: PropTypes.any,\n  refs: PropTypes.object,\n\n  /**\n   * 额外渲染行的渲染函数\n   * @param {Object} record 该行所对应的数据\n   * @param {Number} index 该行所对应的序列\n   * @returns {Element} 渲染内容\n   */\n  expandedRowRender: PropTypes.func,\n\n  /**\n   * 额外渲染行的缩进\n   */\n  expandedRowIndent: PropTypes.array,\n\n  /**\n   * 默认情况下展开的渲染行或者Tree, 传入此属性为受控状态\n   */\n  openRowKeys: PropTypes.array,\n\n  /**\n   * 是否显示点击展开额外渲染行的+号按钮\n   */\n  hasExpandedRowCtrl: PropTypes.bool,\n\n  /**\n   * 设置额外渲染行的属性\n   */\n  getExpandedColProps: PropTypes.func,\n\n  /**\n   * 在额外渲染行或者Tree展开或者收起的时候触发的事件\n   * @param {Array} openRowKeys 展开的渲染行的key\n   * @param {String} currentRowKey 当前点击的渲染行的key\n   * @param {Boolean} expanded 当前点击是展开还是收起\n   * @param {Object} currentRecord 当前点击额外渲染行的记录\n   */\n  onRowOpen: PropTypes.func,\n\n  /**\n   * 点击额外渲染行触发的事件\n   * @param {Object} record 该行所对应的数据\n   * @param {Number} index 该行所对应的序列\n   * @param {Event} e DOM事件对象\n   */\n  onExpandedRowClick: PropTypes.func,\n\n  /**\n   * 表头是否固定，该属性配合maxBodyHeight使用，当内容区域的高度超过maxBodyHeight的时候，在内容区域会出现滚动条\n   */\n  fixedHeader: PropTypes.bool,\n\n  /**\n   * 最大内容区域的高度,在`fixedHeader`为`true`的时候,超过这个高度会出现滚动条\n   */\n  maxBodyHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n\n  /**\n   * 是否启用选择模式\n   * @property {Function} getProps `Function(record, index)=>Object` 获取selection的默认属性\n   * @property {Function} onChange `Function(selectedRowKeys:Array, records:Array)` 选择改变的时候触发的事件，**注意:** 其中records只会包含当前dataSource的数据，很可能会小于selectedRowKeys的长度。\n   * @property {Function} onSelect `Function(selected:Boolean, record:Object, records:Array)` 用户手动选择/取消选择某行的回调\n   * @property {Function} onSelectAll `Function(selected:Boolean, records:Array)` 用户手动选择/取消选择所有行的回调\n   * @property {Array} selectedRowKeys 设置了此属性,将rowSelection变为受控状态,接收值为该行数据的primaryKey的值\n   * @property {String} mode 选择selection的模式, 可选值为`single`, `multiple`，默认为`multiple`\n   */\n  rowSelection: PropTypes.object,\n\n  /**\n   * 表头是否是sticky\n   */\n  stickyHeader: PropTypes.bool,\n\n  /**\n   * 距离窗口顶部达到指定偏移量后触发\n   */\n  offsetTop: PropTypes.number,\n\n  /**\n   * affix组件的的属性\n   */\n  affixProps: PropTypes.object,\n\n  /**\n   * 在tree模式下的缩进尺寸， 仅在isTree为true时候有效\n   */\n  indent: PropTypes.number,\n\n  /**\n   * 开启Table的tree模式, 接收的数据格式中包含children则渲染成tree table\n   */\n  isTree: PropTypes.bool,\n\n  /**\n   * 是否开启虚拟滚动\n   */\n  useVirtual: PropTypes.bool,\n\n  /**\n   * 设置行高\n   */\n  rowHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n\n  /**\n   * 在内容区域滚动的时候触发的函数\n   */\n  onBodyScroll: PropTypes.func\n}, _class.defaultProps = {\n  dataSource: [],\n  onRowClick: noop,\n  onRowMouseEnter: noop,\n  onRowMouseLeave: noop,\n  onSort: noop,\n  onFilter: noop,\n  onResizeChange: noop,\n  getRowProps: noop,\n  getCellProps: noop,\n  prefix: 'next-',\n  hasBorder: true,\n  hasHeader: true,\n  isZebra: false,\n  loading: false,\n  primaryKey: 'id',\n  components: {},\n  locale: zhCN.Table\n}, _class.childContextTypes = {\n  notRenderCellIndex: PropTypes.array,\n  lockType: PropTypes.oneOf(['left', 'right'])\n}, _class.contextTypes = {\n  getTableInstance: PropTypes.func,\n  getTableInstanceForVirtual: PropTypes.func\n}, _temp);\nTable.displayName = 'Table';\nexport { Table as default };","map":null,"metadata":{},"sourceType":"module"}