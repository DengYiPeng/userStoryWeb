{"ast":null,"code":"import _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';\nimport _extends from 'babel-runtime/helpers/extends';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\nimport React, { Children } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport classnames from 'classnames';\nimport shallowElementEquals from 'shallow-element-equals';\nimport { dom, log, obj, events } from '../util';\nimport LockRow from './lock/row';\nimport LockBody from './lock/body';\nimport LockHeader from './lock/header';\nimport LockWrapper from './fixed/wrapper';\nimport { statics } from './util';\nexport default function lock(BaseComponent) {\n  var _class, _temp;\n  /** Table */\n\n\n  var LockTable = (_temp = _class = function (_React$Component) {\n    _inherits(LockTable, _React$Component);\n\n    function LockTable(props, context) {\n      _classCallCheck(this, LockTable);\n\n      var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\n\n      _this.getTableInstance = function (type, instance) {\n        type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';\n        _this['table' + type + 'Inc'] = instance;\n      };\n\n      _this.getNode = function (type, node, lockType) {\n        lockType = lockType ? lockType.charAt(0).toUpperCase() + lockType.substr(1) : '';\n        _this['' + type + lockType + 'Node'] = node;\n\n        if (type === 'header' && !_this.innerHeaderNode && !lockType) {\n          _this.innerHeaderNode = _this.headerNode.querySelector('div');\n        }\n      };\n\n      _this.onRowMouseEnter = function (record, index) {\n        if (_this.isLock()) {\n          var row = _this.getRowNode(index);\n\n          var leftRow = _this.getRowNode(index, 'left');\n\n          var rightRow = _this.getRowNode(index, 'right');\n\n          [row, leftRow, rightRow].forEach(function (row) {\n            row && dom.addClass(row, 'hovered');\n          });\n        }\n      };\n\n      _this.onRowMouseLeave = function (record, index) {\n        if (_this.isLock()) {\n          var row = _this.getRowNode(index);\n\n          var leftRow = _this.getRowNode(index, 'left');\n\n          var rightRow = _this.getRowNode(index, 'right');\n\n          [row, leftRow, rightRow].forEach(function (row) {\n            row && dom.removeClass(row, 'hovered');\n          });\n        }\n      };\n\n      _this.onLockBodyWheel = function (e) {\n        var y = e.deltaY;\n\n        if (_this.isLock()) {\n          var lockRightBody = _this.bodyRightNode,\n              lockLeftBody = _this.bodyLeftNode,\n              scrollNode = _this.bodyNode,\n              scrollTop = scrollNode.scrollTop,\n              clientHeight = scrollNode.clientHeight,\n              scrollHeight = scrollNode.scrollHeight;\n\n          if (lockLeftBody) {\n            lockLeftBody.scrollTop = y;\n          }\n\n          if (lockRightBody) {\n            lockRightBody.scrollTop = y;\n          }\n\n          scrollNode.scrollTop = scrollTop + y;\n          var newScrollTop = scrollNode.scrollTop;\n\n          if (newScrollTop + clientHeight < scrollHeight && newScrollTop) {\n            e.preventDefault();\n          }\n        }\n      };\n\n      _this.onLockBodyScroll = function () {\n        if (_this.isLock()) {\n          var lockRightBody = _this.bodyRightNode,\n              lockLeftBody = _this.bodyLeftNode,\n              lockRightTable = _this.getWrapperNode('right'),\n              lockLeftTable = _this.getWrapperNode('left'),\n              shadowClassName = 'shadow';\n\n          var x = _this.bodyNode.scrollLeft,\n              y = _this.bodyNode.scrollTop;\n\n          if (lockLeftBody) {\n            lockLeftBody.scrollTop = y;\n          }\n\n          if (lockRightBody) {\n            lockRightBody.scrollTop = y;\n          }\n\n          if (x === 0) {\n            lockLeftTable && dom.removeClass(lockLeftTable, shadowClassName);\n            lockRightTable && dom.addClass(lockRightTable, shadowClassName);\n          } else if (x === _this.bodyNode.scrollWidth - _this.bodyNode.clientWidth) {\n            lockLeftTable && dom.addClass(lockLeftTable, shadowClassName);\n            lockRightTable && dom.removeClass(lockRightTable, shadowClassName);\n          } else {\n            lockLeftTable && dom.addClass(lockLeftTable, shadowClassName);\n            lockRightTable && dom.addClass(lockRightTable, shadowClassName);\n          }\n        }\n      };\n\n      _this.lockLeftChildren = [];\n      _this.lockRightChildren = [];\n      return _this;\n    }\n\n    LockTable.prototype.getChildContext = function getChildContext() {\n      return {\n        getTableInstance: this.getTableInstance,\n        getLockNode: this.getNode,\n        onLockBodyWheel: this.onLockBodyWheel,\n        onLockBodyScroll: this.onLockBodyScroll,\n        onRowMouseEnter: this.onRowMouseEnter,\n        onRowMouseLeave: this.onRowMouseLeave\n      };\n    };\n\n    LockTable.prototype.componentDidMount = function componentDidMount() {\n      this.adjustSize = this.adjustSize.bind(this);\n      this.adjustSize();\n      this.scroll();\n      events.on(window, 'resize', this.adjustSize);\n    };\n\n    LockTable.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState, nextContext) {\n      if (nextProps.pure) {\n        var isEqual = shallowElementEquals(nextProps, this.props);\n        return !(isEqual && obj.shallowEqual(nextContext, this.context));\n      }\n\n      return true;\n    };\n\n    LockTable.prototype.componentWillUpdate = function componentWillUpdate() {\n      this._isLock = false;\n    };\n\n    LockTable.prototype.componentDidUpdate = function componentDidUpdate() {\n      this.adjustSize();\n    };\n\n    LockTable.prototype.componentWillUnmount = function componentWillUnmount() {\n      events.off(window, 'resize', this.adjustSize);\n    };\n\n    LockTable.prototype.normalizeChildrenState = function normalizeChildrenState(props) {\n      var children = props.children;\n      children = this.normalizeChildren(children);\n      var splitChildren = this.splitFromNormalizeChildren(children);\n      var lockLeftChildren = splitChildren.lockLeftChildren,\n          lockRightChildren = splitChildren.lockRightChildren;\n      return {\n        lockLeftChildren: lockLeftChildren,\n        lockRightChildren: lockRightChildren,\n        children: this.mergeFromSplitLockChildren(splitChildren)\n      };\n    }; // 将React结构化数据提取props转换成数组\n\n\n    LockTable.prototype.normalizeChildren = function normalizeChildren(children) {\n      var isLock = false;\n\n      var getChildren = function getChildren(children) {\n        var ret = [];\n        Children.forEach(children, function (child) {\n          if (child) {\n            var props = _extends({}, child.props);\n\n            if ([true, 'left', 'right'].indexOf(props.lock) > -1) {\n              isLock = true;\n\n              if (!('width' in props)) {\n                log.warning('Should config width for lock column named [ ' + props.dataIndex + ' ].');\n              }\n            }\n\n            ret.push(props);\n\n            if (child.props.children) {\n              props.children = getChildren(child.props.children);\n            }\n          }\n        });\n        return ret;\n      };\n\n      var ret = getChildren(children);\n      ret.forEach(function (child) {\n        // 为自定义的列特殊处理\n        if (child.__normalized && isLock) {\n          child.lock = 'left';\n          delete child.__normalized;\n        }\n      });\n      this._isLock = isLock;\n      return ret;\n    }; //从数组中分离出lock的列和正常的列\n\n\n    LockTable.prototype.splitFromNormalizeChildren = function splitFromNormalizeChildren(children) {\n      var originChildren = deepCopy(children);\n      var lockLeftChildren = deepCopy(children);\n      var lockRightChildren = deepCopy(children);\n\n      var loop = function loop(lockChildren, condition) {\n        var ret = [];\n        lockChildren.forEach(function (child) {\n          if (child.children) {\n            var res = loop(child.children, condition);\n\n            if (!res.length) {\n              ret.push(child);\n            }\n          } else {\n            var order = condition(child);\n\n            if (!order) {\n              ret.push(child);\n            }\n          }\n        });\n        ret.forEach(function (res) {\n          var index = lockChildren.indexOf(res);\n          lockChildren.splice(index, 1);\n        });\n        return lockChildren;\n      };\n\n      loop(lockLeftChildren, function (child) {\n        if (child.lock === true || child.lock === 'left') {\n          return 'left';\n        }\n      });\n      loop(lockRightChildren, function (child) {\n        if (child.lock === 'right') {\n          return 'right';\n        }\n      });\n      loop(originChildren, function (child) {\n        return child.lock !== true && child.lock !== 'left' && child.lock !== 'right';\n      });\n      return {\n        lockLeftChildren: lockLeftChildren,\n        lockRightChildren: lockRightChildren,\n        originChildren: originChildren\n      };\n    }; //将左侧的锁列树和中间的普通树及右侧的锁列树进行合并\n\n\n    LockTable.prototype.mergeFromSplitLockChildren = function mergeFromSplitLockChildren(splitChildren) {\n      var lockLeftChildren = splitChildren.lockLeftChildren,\n          lockRightChildren = splitChildren.lockRightChildren;\n      var originChildren = splitChildren.originChildren;\n      Array.prototype.unshift.apply(originChildren, lockLeftChildren);\n      originChildren = originChildren.concat(lockRightChildren);\n      return originChildren;\n    };\n\n    LockTable.prototype.scroll = function scroll() {\n      var _props = this.props,\n          _props$scrollToCol = _props.scrollToCol,\n          scrollToCol = _props$scrollToCol === undefined ? 0 : _props$scrollToCol,\n          _props$scrollToRow = _props.scrollToRow,\n          scrollToRow = _props$scrollToRow === undefined ? 0 : _props$scrollToRow;\n\n      if (!scrollToCol && !scrollToRow) {\n        return;\n      }\n\n      var colCellNode = this.getCellNode(0, scrollToCol);\n      var rowCellNode = this.getCellNode(scrollToRow, 0);\n      var bodyNodeOffset = this.bodyNode.getBoundingClientRect();\n\n      if (colCellNode) {\n        var cellNodeoffset = colCellNode.getBoundingClientRect();\n        var scrollLeft = cellNodeoffset.left - bodyNodeOffset.left;\n        this.bodyNode.scrollLeft = scrollLeft;\n      }\n\n      if (rowCellNode) {\n        var _cellNodeoffset = rowCellNode.getBoundingClientRect();\n\n        var scrollTop = _cellNodeoffset.top - bodyNodeOffset.top;\n        this.bodyNode.scrollTop = scrollTop;\n      }\n    }; // Table处理过后真实的lock状态\n\n\n    LockTable.prototype.isLock = function isLock() {\n      return this.lockLeftChildren.length || this.lockRightChildren.length;\n    }; // 用户设置的lock状态\n\n\n    LockTable.prototype.isOriginLock = function isOriginLock() {\n      return this._isLock;\n    };\n\n    LockTable.prototype.adjustSize = function adjustSize() {\n      if (!this.adjustIfTableNotNeedLock()) {\n        this.adjustHeaderSize();\n        this.adjustBodySize();\n        this.adjustCellSize();\n        this.onLockBodyScroll();\n      }\n    };\n\n    LockTable.prototype.adjustIfTableNotNeedLock = function adjustIfTableNotNeedLock() {\n      var _this2 = this;\n\n      if (this.isOriginLock() && this.tableInc.props.dataSource.length) {\n        var configWidths = this.tableInc.flatChildren.map(function (item, index) {\n          var row = _this2.getCellNode(0, index);\n\n          return row && row.clientWidth || 0;\n        }).reduce(function (a, b) {\n          return a + b;\n        }, 0);\n        var node = findDOMNode(this);\n        var width = node.clientWidth;\n        var lockLeftLen = this.lockLeftChildren.length;\n        var lockRightLen = this.lockRightChildren.length;\n\n        if (configWidths <= width && configWidths > 0) {\n          if (lockLeftLen) {\n            this._notNeedAdjustLockLeft = true;\n          }\n\n          if (lockRightLen) {\n            this._notNeedAdjustLockRight = true;\n          }\n\n          if (lockRightLen || lockLeftLen) {\n            this.forceUpdate();\n            return true;\n          }\n        } else if (this._notNeedAdjustLockLeft || this._notNeedAdjustLockRight) {\n          this._notNeedAdjustLockLeft = this._notNeedAdjustLockRight = false;\n          this.forceUpdate();\n        } else {\n          this._notNeedAdjustLockLeft = this._notNeedAdjustLockRight = false;\n          return false;\n        }\n      }\n\n      return false;\n    };\n\n    LockTable.prototype.adjustBodySize = function adjustBodySize() {\n      if (this.isLock()) {\n        var body = this.bodyNode,\n            lockLeftBody = this.bodyLeftNode,\n            lockRightBody = this.bodyRightNode,\n            lockRightBodyWrapper = this.getWrapperNode('right'),\n            scrollbar = dom.scrollbar(),\n            bodyHeight = body.offsetHeight,\n            hasHozScroll = body.scrollWidth > body.clientWidth,\n            hasVerScroll = body.scrollHeight > body.clientHeight,\n            width = hasVerScroll ? scrollbar.width : 0,\n            lockBodyHeight = bodyHeight - (hasHozScroll ? scrollbar.height : 0);\n        lockLeftBody && dom.setStyle(lockLeftBody, 'max-height', lockBodyHeight);\n        lockRightBody && dom.setStyle(lockRightBody, 'max-height', lockBodyHeight);\n        lockRightBodyWrapper && dom.setStyle(lockRightBodyWrapper, 'right', width);\n      }\n    };\n\n    LockTable.prototype.adjustHeaderSize = function adjustHeaderSize() {\n      var _this3 = this;\n\n      if (this.isLock()) {\n        this.tableInc.groupChildren.forEach(function (child, index) {\n          var lastIndex = _this3.tableInc.groupChildren[index].length - 1;\n\n          var headerRightRow = _this3.getHeaderCellNode(index, lastIndex),\n              headerLeftRow = _this3.getHeaderCellNode(index, 0),\n              headerRightLockRow = _this3.getHeaderCellNode(index, 0, 'right'),\n              headerLeftLockRow = _this3.getHeaderCellNode(index, 0, 'left');\n\n          if (headerRightRow && headerRightLockRow) {\n            var maxRightRowHeight = headerRightRow.offsetHeight;\n            dom.setStyle(headerRightLockRow, 'height', maxRightRowHeight);\n            setTimeout(function () {\n              _this3.tableRightInc.affixRef && _this3.tableRightInc.affixRef.getInstance().updatePosition();\n            });\n          }\n\n          if (headerLeftRow && headerLeftLockRow) {\n            var maxLeftRowHeight = headerLeftRow.offsetHeight;\n            dom.setStyle(headerLeftLockRow, 'height', maxLeftRowHeight);\n            setTimeout(function () {\n              _this3.tableLeftInc.affixRef && _this3.tableLeftInc.affixRef.getInstance().updatePosition();\n            });\n          }\n        });\n      }\n    };\n\n    LockTable.prototype.adjustCellSize = function adjustCellSize() {\n      var _this4 = this;\n\n      if (this.isLock()) {\n        this.tableInc.props.dataSource.forEach(function (item, index) {\n          var lockLeftRow = _this4.getCellNode(index, 0, 'left'),\n              lockRightRow = _this4.getCellNode(index, 0, 'right'),\n              row = _this4.getFirstNormalCellNode(index),\n              rowHeight = row && parseFloat(getComputedStyle(row).height) || 0;\n\n          var lockLeftHeight = 0,\n              lockRightHeight = 0;\n\n          if (lockLeftRow) {\n            lockLeftHeight = lockLeftRow.offsetHeight;\n          }\n\n          if (lockRightRow) {\n            lockRightHeight = lockRightRow.offsetHeight;\n          }\n\n          if (lockLeftRow && rowHeight !== lockLeftHeight) {\n            dom.setStyle(lockLeftRow, 'height', rowHeight);\n          }\n\n          if (lockRightRow && rowHeight !== lockRightHeight) {\n            dom.setStyle(lockRightRow, 'height', rowHeight);\n          }\n        });\n      }\n    };\n\n    LockTable.prototype.getWrapperNode = function getWrapperNode(type) {\n      type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';\n\n      try {\n        // in case of finding an unmounted component due to cached data\n        // need to clear refs of table when dataSource Changed\n        // use try catch for temporary\n        return findDOMNode(this.refs['lock' + type]);\n      } catch (error) {\n        return null;\n      }\n    };\n\n    LockTable.prototype.getFirstNormalCellNode = function getFirstNormalCellNode(index) {\n      var i = 0;\n      var row = void 0;\n\n      do {\n        row = this.getCellNode(index, i);\n        i++;\n      } while ((!row || row && row.rowSpan && row.rowSpan > 1) && this.tableInc.flatChildren.length > i);\n\n      return row;\n    };\n\n    LockTable.prototype.getRowNode = function getRowNode(index, type) {\n      type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';\n      var table = this['table' + type + 'Inc'];\n\n      try {\n        // in case of finding an unmounted component due to cached data\n        // need to clear refs of table when dataSource Changed\n        // use try catch for temporary\n        return findDOMNode(table.getRowRef(index));\n      } catch (error) {\n        return null;\n      }\n    };\n\n    LockTable.prototype.getHeaderCellNode = function getHeaderCellNode(index, i, type) {\n      type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';\n      var table = this['table' + type + 'Inc'];\n\n      try {\n        // in case of finding an unmounted component due to cached data\n        // need to clear refs of table when dataSource Changed\n        // use try catch for temporary\n        return findDOMNode(table.getHeaderCellRef(index, i));\n      } catch (error) {\n        return null;\n      }\n    };\n\n    LockTable.prototype.getCellNode = function getCellNode(index, i, type) {\n      type = type ? type.charAt(0).toUpperCase() + type.substr(1) : '';\n      var table = this['table' + type + 'Inc'];\n\n      try {\n        // in case of finding an unmounted component due to cached data\n        // need to clear refs of table when dataSource Changed\n        // use try catch for temporary\n        return findDOMNode(table.getCellRef(index, i));\n      } catch (error) {\n        return null;\n      }\n    };\n\n    LockTable.prototype.render = function render() {\n      /* eslint-disable no-unused-vars, prefer-const */\n      var _props2 = this.props,\n          children = _props2.children,\n          prefix = _props2.prefix,\n          components = _props2.components,\n          className = _props2.className,\n          others = _objectWithoutProperties(_props2, ['children', 'prefix', 'components', 'className']);\n\n      var _normalizeChildrenSta = this.normalizeChildrenState(this.props),\n          lockLeftChildren = _normalizeChildrenSta.lockLeftChildren,\n          lockRightChildren = _normalizeChildrenSta.lockRightChildren,\n          normalizedChildren = _normalizeChildrenSta.children;\n\n      if (this._notNeedAdjustLockLeft) {\n        lockLeftChildren = [];\n      }\n\n      if (this._notNeedAdjustLockRight) {\n        lockRightChildren = [];\n      }\n\n      this.lockLeftChildren = lockLeftChildren;\n      this.lockRightChildren = lockRightChildren;\n\n      if (this.isOriginLock()) {\n        var _classnames;\n\n        components = _extends({}, components);\n        components.Body = components.Body || LockBody;\n        components.Header = components.Header || LockHeader;\n        components.Wrapper = components.Wrapper || LockWrapper;\n        components.Row = components.Row || LockRow;\n        className = classnames((_classnames = {}, _classnames[prefix + 'table-lock'] = true, _classnames[className] = className, _classnames));\n        var content = [React.createElement(BaseComponent, _extends({}, others, {\n          key: 'lock-left',\n          columns: lockLeftChildren,\n          className: prefix + 'table-lock-left',\n          prefix: prefix,\n          lockType: 'left',\n          components: components,\n          ref: 'lockLeft',\n          loading: false\n        })), React.createElement(BaseComponent, _extends({}, others, {\n          key: 'lock-right',\n          columns: lockRightChildren,\n          className: prefix + 'table-lock-right',\n          prefix: prefix,\n          lockType: 'right',\n          components: components,\n          ref: 'lockRight',\n          loading: false\n        }))];\n        return React.createElement(BaseComponent, _extends({}, others, {\n          columns: normalizedChildren,\n          prefix: prefix,\n          wrapperContent: content,\n          components: components,\n          className: className\n        }));\n      }\n\n      return React.createElement(BaseComponent, this.props);\n    };\n\n    return LockTable;\n  }(React.Component), _class.LockRow = LockRow, _class.LockBody = LockBody, _class.LockHeader = LockHeader, _class.propTypes = _extends({\n    scrollToCol: PropTypes.number,\n\n    /**\n     * 指定滚动到某一行，仅在`useVirtual`的时候生效\n     */\n    scrollToRow: PropTypes.number\n  }, BaseComponent.propTypes), _class.defaultProps = _extends({}, BaseComponent.defaultProps), _class.childContextTypes = {\n    getTableInstance: PropTypes.func,\n    getLockNode: PropTypes.func,\n    onLockBodyScroll: PropTypes.func,\n    onLockBodyWheel: PropTypes.func,\n    onRowMouseEnter: PropTypes.func,\n    onRowMouseLeave: PropTypes.func\n  }, _temp);\n  LockTable.displayName = 'LockTable';\n  statics(LockTable, BaseComponent);\n  return LockTable;\n}\n\nfunction deepCopy(arr) {\n  var copy = function copy(arr) {\n    return arr.map(function (item) {\n      var newItem = _extends({}, item);\n\n      if (item.children) {\n        item.children = copy(item.children);\n      }\n\n      return newItem;\n    });\n  };\n\n  return copy(arr);\n}","map":null,"metadata":{},"sourceType":"module"}