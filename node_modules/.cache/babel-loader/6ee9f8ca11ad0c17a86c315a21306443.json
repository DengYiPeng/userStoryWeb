{"ast":null,"code":"import _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\nimport _extends from 'babel-runtime/helpers/extends';\n\nvar _class, _temp;\n\nimport classNames from 'classnames';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { events, func } from '../../util';\nimport Balloon from '../../balloon';\nimport { getPercent, getPrecision, isEqual, getDragging } from '../utils';\nimport Scale from './scale';\nimport Track from './track';\nimport Selected from './selected';\nimport Mark from './mark';\nimport Slider from './slider';\nimport FixedSlider from './fixedSlider';\nvar Tooltip = Balloon.Tooltip;\nvar noop = func.noop,\n    bindCtx = func.bindCtx;\n\nfunction _isMultiple(slider, isFixedWidth) {\n  return isFixedWidth || slider === 'double';\n}\n\nfunction LowerSlider(props) {\n  var hasTip = props.hasTip,\n      value = props.value,\n      tipRender = props.tipRender,\n      slider = props.slider,\n      tooltipVisible = props.tooltipVisible,\n      onTooltipVisibleChange = props.onTooltipVisibleChange,\n      tooltipAnimation = props.tooltipAnimation;\n\n  if (_isMultiple(slider)) {\n    return hasTip ? React.createElement(Tooltip, {\n      popupContainer: function popupContainer(target) {\n        return target.parentNode;\n      },\n      popupProps: {\n        visible: tooltipVisible,\n        onVisibleChange: onTooltipVisibleChange,\n        animation: tooltipAnimation\n      },\n      trigger: Slider(_extends({}, props, {\n        value: value[0]\n      })),\n      align: 't'\n    }, tipRender('' + value[0])) : Slider(_extends({}, props, {\n      value: value[0]\n    }));\n  }\n\n  return null;\n}\n\nLowerSlider.propTypes = {\n  hasTip: PropTypes.bool,\n  tooltipVisible: PropTypes.bool,\n  onTooltipVisibleChange: PropTypes.func,\n  tooltipAnimation: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n  value: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n  tipRender: PropTypes.func,\n  slider: PropTypes.oneOf(['single', 'double'])\n};\n\nfunction UpperSlider(props) {\n  var hasTip = props.hasTip,\n      value = props.value,\n      tipRender = props.tipRender,\n      slider = props.slider,\n      tooltipVisible = props.tooltipVisible,\n      onTooltipVisibleChange = props.onTooltipVisibleChange,\n      tooltipAnimation = props.tooltipAnimation;\n\n  if (_isMultiple(slider)) {\n    return hasTip ? React.createElement(Tooltip, {\n      popupContainer: function popupContainer(target) {\n        return target.parentNode;\n      },\n      popupProps: {\n        visible: tooltipVisible,\n        onVisibleChange: onTooltipVisibleChange,\n        animation: tooltipAnimation\n      },\n      trigger: Slider(_extends({}, props, {\n        value: value[1]\n      })),\n      align: 't'\n    }, tipRender(value[1])) : Slider(_extends({}, props, {\n      value: value[1]\n    }));\n  }\n\n  return hasTip ? React.createElement(Tooltip, {\n    popupContainer: function popupContainer(target) {\n      return target.parentNode;\n    },\n    popupProps: {\n      visible: tooltipVisible,\n      onVisibleChange: onTooltipVisibleChange,\n      animation: tooltipAnimation\n    },\n    animation: {\n      in: 'fadeInUp',\n      out: 'fadeOutDown'\n    },\n    trigger: Slider(props),\n    align: 't'\n  }, tipRender(value)) : Slider(props);\n}\n\nUpperSlider.propTypes = {\n  hasTip: PropTypes.bool,\n  tooltipVisible: PropTypes.bool,\n  onTooltipVisibleChange: PropTypes.func,\n  tooltipAnimation: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n  value: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n  tipRender: PropTypes.func,\n  slider: PropTypes.oneOf(['single', 'double'])\n};\n\nfunction pauseEvent(e) {\n  e.stopPropagation();\n  e.preventDefault();\n}\n/** Range */\n\n\nvar Range = (_temp = _class = function (_React$Component) {\n  _inherits(Range, _React$Component);\n\n  function Range(props) {\n    _classCallCheck(this, Range);\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));\n\n    var min = props.min;\n    var initialValue = _isMultiple(props.slider) ? [min, min] : min;\n    var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;\n    var value = props.value !== undefined ? props.value : defaultValue;\n    _this.state = {\n      value: value,\n      tempValue: value,\n      hasMovingClass: false,\n      lowerTooltipVisible: false,\n      upperTooltipVisible: false,\n      tooltipAnimation: true\n    };\n    bindCtx(_this, ['handleLowerTooltipVisibleChange', 'handleUpperTooltipVisibleChange']);\n    return _this;\n  }\n\n  Range.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var min = this.props.min;\n    var initialValue = _isMultiple(nextProps.slider) ? [min, min] : min;\n\n    if ('value' in nextProps) {\n      var value = nextProps.value;\n\n      if (value === undefined) {\n        // value设置undefined,reset为初始值\n        value = initialValue;\n      }\n\n      this.setState({\n        value: value,\n        tempValue: value\n      });\n    }\n  };\n\n  Range.prototype._marksToScales = function _marksToScales(marks) {\n    var result = [];\n\n    if (Object.prototype.toString.call(marks) === '[object Object]') {\n      for (var key in marks) {\n        if (Object.hasOwnProperty.call(marks, key)) {\n          result.push(parseInt(key));\n        }\n      }\n    } else {\n      result = marks;\n    }\n\n    return result;\n  };\n\n  Range.prototype._calcScales = function _calcScales() {\n    var _props = this.props,\n        min = _props.min,\n        max = _props.max,\n        marks = _props.marks;\n\n    var scales = this._marksToScales(marks); // let scales = null;\n\n\n    if (scales !== false) {\n      if (Array.isArray(scales)) {\n        return scales;\n      } else {\n        var pace = (max - min) / scales;\n        var result = [];\n        result.push(min);\n\n        for (var i = 1; i < scales; i++) {\n          result.push(min + i * pace);\n        }\n\n        result.push(max);\n        return result;\n      }\n    } else {\n      return [];\n    }\n  };\n\n  Range.prototype._calcMarks = function _calcMarks() {\n    var _props2 = this.props,\n        min = _props2.min,\n        max = _props2.max,\n        marks = _props2.marks;\n    var result = {};\n\n    if (Array.isArray(marks)) {\n      marks.forEach(function (m) {\n        result[m] = m.toString();\n      });\n    } else if (typeof marks === 'number') {\n      var pace = (max - min) / marks;\n      result[min] = min;\n\n      for (var i = 1; i < marks; i++) {\n        var mark = min + i * pace;\n        var precision = getPrecision(mark);\n\n        if (precision > 2) {\n          precision = 2;\n        }\n\n        mark = mark.toFixed(precision);\n        result[mark] = mark;\n      }\n\n      result[max] = max;\n    } else {\n      result = marks;\n    }\n\n    return result;\n  };\n\n  Range.prototype._onMouseDown = function _onMouseDown(e) {\n    if (e.button === 0) {\n      this.setState({\n        hasMovingClass: true\n      });\n\n      this._start(e.pageX);\n\n      this._addDocumentEvents();\n\n      pauseEvent(e);\n    }\n  };\n\n  Range.prototype._start = function _start(position) {\n    var tempValue = this.state.tempValue;\n    var range = this.dom;\n    var start = range.getBoundingClientRect().left; // used in unit test\n\n    var width = range.clientWidth;\n\n    if (!width) {\n      if (range.style.width) {\n        var index = range.style.width.indexOf('px');\n\n        if (index !== -1) {\n          width = Number(range.style.width.slice(0, index));\n        }\n      }\n    }\n\n    this._moving = {\n      start: start,\n      end: start + width,\n      startValue: tempValue\n    }; // change on start\n\n    this._onProcess(position, true);\n  };\n\n  Range.prototype._end = function _end() {\n    var startValue = this._moving.startValue;\n    var _state = this.state,\n        tempValue = _state.tempValue,\n        value = _state.value;\n    this._moving = null;\n\n    this._removeDocumentEvents();\n\n    this.setState({\n      hasMovingClass: false,\n      lowerTooltipVisible: false,\n      upperTooltipVisible: false,\n      tooltipAnimation: true\n    });\n\n    if (!isEqual(tempValue, startValue)) {\n      // Not Controlled\n      if (!('value' in this.props)) {\n        this.setState({\n          value: tempValue\n        });\n      } else {\n        this.setState({\n          // tooltipVisible: false,\n          tempValue: value,\n          value: value\n        });\n      }\n\n      this.props.onChange(tempValue);\n    }\n  };\n\n  Range.prototype._move = function _move(e) {\n    this._onProcess(e.pageX);\n  };\n\n  Range.prototype._onProcess = function _onProcess(position, start) {\n    var tempValue = this.state.tempValue;\n\n    var current = this._positionToCurrent(position); //current 为当前click的value\n\n\n    if (this.isFixedWidth) {\n      if (start) {\n        this.lastPosition = current;\n      }\n    } else if (start) {\n      this.lastPosition = current;\n\n      if (_isMultiple(this.props.slider)) {\n        this._moving.dragging = getDragging(current, tempValue);\n      } else {\n        this._moving.dragging = 'upper';\n      }\n\n      this.setState({\n        lowerTooltipVisible: this._moving.dragging === 'lower',\n        upperTooltipVisible: this._moving.dragging === 'upper',\n        tooltipAnimation: false\n      });\n    } else if (this.oldDragging === 'lower' && this._moving.dragging === 'upper') {\n      this.setState({\n        upperTooltipVisible: true,\n        lowerTooltipVisible: false\n      });\n    } else if (this.oldDragging === 'upper' && this._moving.dragging === 'lower') {\n      this.setState({\n        upperTooltipVisible: false,\n        lowerTooltipVisible: true\n      });\n    }\n\n    this.oldDragging = this._moving.dragging;\n\n    var nextValue = this._currentToValue(current, tempValue, this.lastPosition, this.isFixedWidth); //计算range的新value,可能是数组,可能是单个值\n\n\n    this.lastPosition = current;\n\n    if (!isEqual(nextValue, tempValue)) {\n      this.setState({\n        tempValue: nextValue\n      });\n      this.props.onProcess(nextValue);\n    }\n  };\n\n  Range.prototype._addDocumentEvents = function _addDocumentEvents() {\n    this._onMouseMoveListener = events.on(document, 'mousemove', this._move.bind(this));\n    this._onMouseUpListener = events.on(document, 'mouseup', this._end.bind(this));\n  };\n\n  Range.prototype._removeDocumentEvents = function _removeDocumentEvents() {\n    if (this._onMouseMoveListener) {\n      this._onMouseMoveListener.off();\n\n      this._onMouseMoveListener = null;\n    }\n\n    if (this._onMouseUpListener) {\n      this._onMouseUpListener.off();\n\n      this._onMouseUpListener = null;\n    }\n  }; // position => current (value type)\n\n\n  Range.prototype._positionToCurrent = function _positionToCurrent(position) {\n    var _moving = this._moving,\n        start = _moving.start,\n        end = _moving.end;\n    var _props3 = this.props,\n        step = _props3.step,\n        min = _props3.min,\n        max = _props3.max;\n\n    if (position < start) {\n      position = start;\n    } else if (position > end) {\n      position = end;\n    }\n\n    var percent = getPercent(start, end, position); // reset by step\n\n    var newValue = parseFloat((Math.round(percent / 100 * (max - min) / step) * step).toFixed(getPrecision(step)));\n    return min + newValue;\n  };\n\n  Range.prototype._currentToValue = function _currentToValue(current, preValue, lastPosition, isFixedWidth) {\n    var dragging = this._moving.dragging;\n\n    if (!_isMultiple(this.props.slider, isFixedWidth)) {\n      return current;\n    } else {\n      var result = void 0;\n      var _props4 = this.props,\n          min = _props4.min,\n          max = _props4.max;\n      var precision = getPrecision(this.props.step);\n      var diff = current - lastPosition;\n      var newLeft = +(+preValue[0] + diff).toFixed(precision);\n      var newRight = +(+preValue[1] + diff).toFixed(precision);\n      var newMaxLeft = +(max - preValue[1] + preValue[0]).toFixed(precision);\n      var newMinRight = +(min + preValue[1] - preValue[0]).toFixed(precision);\n\n      if (isFixedWidth) {\n        if (newLeft < min) {\n          result = [min, newMinRight];\n        } else if (newRight > max) {\n          result = [newMaxLeft, max];\n        } else {\n          result = [newLeft, newRight];\n        }\n      } else if (dragging === 'lower') {\n        if (current > preValue[1]) {\n          result = [preValue[1], current];\n          this._moving.dragging = 'upper';\n        } else {\n          result = [current, preValue[1]];\n        }\n      } else if (dragging === 'upper') {\n        if (current < preValue[0]) {\n          result = [current, preValue[0]];\n          this._moving.dragging = 'lower';\n        } else {\n          result = [preValue[0], current];\n        }\n      }\n\n      return result;\n    }\n  };\n\n  Range.prototype.handleLowerTooltipVisibleChange = function handleLowerTooltipVisibleChange(visible) {\n    if (this.state.hasMovingClass) {\n      return;\n    }\n\n    this.setState({\n      lowerTooltipVisible: visible\n    });\n  };\n\n  Range.prototype.handleUpperTooltipVisibleChange = function handleUpperTooltipVisibleChange(visible) {\n    if (this.state.hasMovingClass) {\n      return;\n    }\n\n    this.setState({\n      upperTooltipVisible: visible\n    });\n  };\n\n  Range.prototype.render = function render() {\n    var _classNames,\n        _this2 = this;\n\n    var value = this._moving ? this.state.tempValue : this.state.value;\n    var _props5 = this.props,\n        prefix = _props5.prefix,\n        min = _props5.min,\n        max = _props5.max,\n        disabled = _props5.disabled,\n        style = _props5.style,\n        id = _props5.id,\n        slider = _props5.slider,\n        reverse = _props5.reverse,\n        className = _props5.className,\n        marks = _props5.marks,\n        marksPosition = _props5.marksPosition,\n        hasTip = _props5.hasTip,\n        tipRender = _props5.tipRender,\n        fixedWidth = _props5.fixedWidth,\n        defaultValue = _props5.defaultValue,\n        tooltipVisible = _props5.tooltipVisible;\n    var classes = classNames((_classNames = {}, _classNames[prefix + 'range'] = true, _classNames.disabled = disabled, _classNames[className] = className, _classNames));\n\n    if (Array.isArray(value)) {\n      value.forEach(function (item, index) {\n        if (item > max) {\n          value[index] = max;\n        }\n      });\n    } else if (value > max) {\n      value = max;\n    }\n\n    var commonProps = {\n      prefix: prefix,\n      min: min,\n      max: max,\n      value: value,\n      reverse: reverse,\n      slider: slider,\n      hasTip: hasTip,\n      tipRender: tipRender,\n      marksPosition: marksPosition,\n      tooltipVisible: tooltipVisible,\n      hasMovingClass: this.state.hasMovingClass,\n      disabled: disabled\n    };\n    this.isFixedWidth = fixedWidth && (value ? Array.isArray(value) : defaultValue ? Array.isArray(defaultValue) : false);\n    return React.createElement('div', {\n      ref: function ref(dom) {\n        _this2.dom = dom;\n      },\n      className: classes,\n      id: id,\n      onMouseDown: disabled ? noop : this._onMouseDown.bind(this),\n      style: style\n    }, marks !== false && marksPosition === 'above' ? React.createElement(Mark, _extends({}, commonProps, {\n      marks: this._calcMarks()\n    })) : null, React.createElement('div', {\n      className: prefix + 'range-inner'\n    }, React.createElement(Scale, _extends({}, commonProps, {\n      scales: this._calcScales()\n    })), React.createElement(Track, commonProps), this.isFixedWidth ? React.createElement(FixedSlider, commonProps) : React.createElement('div', null, React.createElement(Selected, commonProps), React.createElement(LowerSlider, _extends({}, commonProps, {\n      hasMovingClass: this.state.hasMovingClass && this._moving && this._moving.dragging === 'lower',\n      tooltipVisible: tooltipVisible || this.state.lowerTooltipVisible,\n      onTooltipVisibleChange: this.handleLowerTooltipVisibleChange,\n      tooltipAnimation: this.state.tooltipAnimation ? {\n        in: 'expandInUp',\n        out: 'expandOutDown'\n      } : false\n    })), React.createElement(UpperSlider, _extends({}, commonProps, {\n      hasMovingClass: this.state.hasMovingClass && this._moving && this._moving.dragging === 'upper',\n      tooltipVisible: tooltipVisible || this.state.upperTooltipVisible,\n      onTooltipVisibleChange: this.handleUpperTooltipVisibleChange,\n      tooltipAnimation: this.state.tooltipAnimation ? {\n        in: 'expandInUp',\n        out: 'expandOutDown'\n      } : false\n    })))), marks !== false && marksPosition === 'below' ? React.createElement(Mark, _extends({}, commonProps, {\n      marks: this._calcMarks()\n    })) : null);\n  };\n\n  return Range;\n}(React.Component), _class.contextTypes = {\n  prefix: PropTypes.string\n}, _class.propTypes = {\n  /**\n   * 样式类名的品牌前缀\n   */\n  prefix: PropTypes.string,\n\n  /**\n   * 自定义类名\n   */\n  className: PropTypes.string,\n\n  /**\n   * 自定义内敛样式\n   */\n  style: PropTypes.object,\n\n  /**\n   * 滑块个数\n   * @enumdesc 单个, 两个\n   */\n  slider: PropTypes.oneOf(['single', 'double']),\n\n  /**\n   * 最小值\n   */\n  min: PropTypes.number,\n\n  /**\n   * 最大值\n   */\n  max: PropTypes.number,\n\n  /**\n   * 步长，取值必须大于 0，并且可被 (max - min) 整除。\n   */\n  step: PropTypes.number,\n\n  /**\n   * 设置当前取值。当 `slider` 为 `single` 时，使用 `Number`，否则用 `[Number, Number]`\n   */\n  value: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n  tempValue: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n\n  /**\n   * 设置初始取值。当 `slider` 为 `single` 时，使用 `Number`，否则用 `[Number, Number]`\n   */\n  defaultValue: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n\n  /**\n   * 刻度数值显示逻辑（false 代表不显示，array 枚举显示的值，number 代表按 number 平分，object 表示按 key 划分，value 值显示）\n   */\n  marks: PropTypes.oneOfType([PropTypes.bool, PropTypes.number, PropTypes.arrayOf(PropTypes.number), PropTypes.object]),\n\n  /**\n   * marks显示在上方('above')or下方('below')\n   */\n  marksPosition: PropTypes.oneOf(['above', 'below']),\n\n  /**\n   * 值为 `true` 时，滑块为禁用状态\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * 当 Range 的值发生改变后，会触发 onChange 事件，并把改变后的值作为参数传入, 如果设置了value, 要配合此函数做受控使用\n   * @param {String/number} value\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * 滑块拖动的时候触发的事件,不建议在这里setState, 一般情况下不需要用, 滑动时有特殊需求时使用\n   * @param {String/number} value\n   */\n  onProcess: PropTypes.func,\n\n  /**\n   * 是否显示 tip\n   */\n  hasTip: PropTypes.bool,\n\n  /**\n   * 自定义 tip 显示内容\n   * @param {Number|String} value 值\n   * @return {ReactNode} 显示内容\n   */\n  tipRender: PropTypes.func,\n  id: PropTypes.string,\n\n  /**\n   * 选中态反转\n   */\n  reverse: PropTypes.bool,\n\n  /**\n   * 是否pure render\n   */\n  pure: PropTypes.bool,\n\n  /**\n   * 是否为拖动线段类型,默认slider为double, defaultValue必传且指定区间\n   */\n  fixedWidth: PropTypes.bool,\n\n  /**\n   * tooltip是否默认展示\n   */\n  tooltipVisible: PropTypes.bool\n}, _class.defaultProps = {\n  prefix: 'next-',\n  slider: 'single',\n  min: 0,\n  max: 100,\n  step: 1,\n  marks: false,\n  disabled: false,\n  fixedWidth: false,\n  tooltipVisible: false,\n  hasTip: true,\n  onChange: noop,\n  onProcess: noop,\n  tipRender: function tipRender(value) {\n    return value;\n  },\n  reverse: false,\n  pure: false,\n  marksPosition: 'above'\n}, _temp);\nRange.displayName = 'Range';\nexport { Range as default };","map":null,"metadata":{},"sourceType":"module"}