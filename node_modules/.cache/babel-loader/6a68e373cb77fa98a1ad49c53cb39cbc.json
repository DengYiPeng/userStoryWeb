{"ast":null,"code":"import _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';\nimport _extends from 'babel-runtime/helpers/extends';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\n\nvar _class, _temp;\n\nimport React, { Component, Children, cloneElement } from 'react';\nimport PropTypes from 'prop-types';\nimport cx from 'classnames';\nimport ConfigProvider from '../../config-provider';\nimport { func, dom, obj } from '../../util';\nimport TreeNode from './tree-node';\nimport { normalizeToArray, isDescendantOrSelf, isSiblingOrSelf, filterChildKey, filterParentKey, getAllCheckedKeys } from './util';\nvar bindCtx = func.bindCtx;\nvar getOffset = dom.getOffset;\nvar pickOthers = obj.pickOthers,\n    isPlainObject = obj.isPlainObject;\n/**\n * Tree\n */\n\nvar Tree = (_temp = _class = function (_Component) {\n  _inherits(Tree, _Component);\n\n  function Tree(props) {\n    _classCallCheck(this, Tree);\n\n    var _this = _possibleConstructorReturn(this, _Component.call(this, props));\n\n    _this.updateCache(props);\n\n    _this.indeterminateKeys = [];\n    _this.state = {\n      expandedKeys: _this.getExpandedKeys(props),\n      selectedKeys: _this.getSelectedKeys(props),\n      checkedKeys: _this.getCheckedKeys(props)\n    };\n    bindCtx(_this, ['handleExpand', 'handleSelect', 'handleCheck']);\n    return _this;\n  }\n\n  Tree.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    this.updateCache(nextProps);\n    var st = {};\n\n    if ('expandedKeys' in nextProps) {\n      st.expandedKeys = this.getExpandedKeys(nextProps, true);\n    }\n\n    if ('selectedKeys' in nextProps) {\n      st.selectedKeys = this.getSelectedKeys(nextProps, true);\n    }\n\n    if ('checkedKeys' in nextProps) {\n      st.checkedKeys = this.getCheckedKeys(nextProps, true);\n    }\n\n    if (Object.keys(st).length) {\n      this.setState(st);\n    }\n  };\n\n  Tree.prototype.updateCache = function updateCache(props) {\n    var _this2 = this;\n\n    this._k2n = {};\n    this._p2n = {};\n\n    if ('dataSource' in props) {\n      var loop = function loop(data) {\n        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '0';\n        return data.forEach(function (item, index) {\n          var pos = prefix + '-' + index;\n          var key = item.key;\n          key = key || pos;\n\n          var newItem = _extends({}, item, {\n            key: key,\n            pos: pos\n          });\n\n          var children = item.children;\n\n          if (children && children.length) {\n            loop(children, pos);\n          }\n\n          _this2._k2n[key] = _this2._p2n[pos] = newItem;\n        });\n      };\n\n      loop(props.dataSource);\n    } else if ('children' in props) {\n      var _loop = function _loop(children) {\n        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '0';\n        return Children.map(children, function (node, index) {\n          var pos = prefix + '-' + index;\n          var key = node.key;\n          key = key || pos;\n\n          var newItem = _extends({}, node.props, {\n            key: key,\n            pos: pos\n          });\n\n          var children = node.props.children;\n\n          if (children && Children.count(children)) {\n            newItem.children = _loop(children, pos);\n          }\n\n          _this2._k2n[key] = _this2._p2n[pos] = newItem;\n          return newItem;\n        });\n      };\n\n      _loop(props.children);\n    }\n  };\n\n  Tree.prototype.getExpandedKeys = function getExpandedKeys(props, willReceiveProps) {\n    var _this3 = this;\n\n    var expandedKeys = void 0;\n\n    if (!willReceiveProps && props.defaultExpandAll) {\n      expandedKeys = Object.keys(this._k2n).filter(function (key) {\n        var children = _this3._k2n[key].children;\n        return children && children.length;\n      });\n    } else {\n      expandedKeys = 'expandedKeys' in props ? props.expandedKeys : willReceiveProps ? [] : props.defaultExpandedKeys;\n      expandedKeys = normalizeToArray(expandedKeys);\n\n      if (props.autoExpandParent) {\n        var newExpandedKeys = [];\n        var expandedPoss = expandedKeys.reduce(function (ret, key) {\n          var pos = _this3._k2n[key] && _this3._k2n[key].pos;\n\n          if (pos) {\n            ret.push(pos);\n            newExpandedKeys.push(key);\n          }\n\n          return ret;\n        }, []);\n        expandedPoss.forEach(function (pos) {\n          var nums = pos.split('-');\n\n          if (nums.length === 2) {\n            return;\n          }\n\n          for (var i = 1; i <= nums.length - 2; i++) {\n            var ancestorPos = nums.slice(0, i + 1).join('-');\n            var ancestorKey = _this3._p2n[ancestorPos].key;\n\n            if (newExpandedKeys.indexOf(ancestorKey) === -1) {\n              newExpandedKeys.push(ancestorKey);\n            }\n          }\n        });\n        return newExpandedKeys;\n      }\n    }\n\n    return expandedKeys;\n  };\n\n  Tree.prototype.getSelectedKeys = function getSelectedKeys(props, willReceiveProps) {\n    var _this4 = this;\n\n    var selectedKeys = 'selectedKeys' in props ? props.selectedKeys : willReceiveProps ? [] : props.defaultSelectedKeys;\n    selectedKeys = normalizeToArray(selectedKeys);\n    var newSelectKeys = selectedKeys.filter(function (key) {\n      return _this4._k2n[key];\n    });\n    return newSelectKeys;\n  };\n\n  Tree.prototype.getCheckedKeys = function getCheckedKeys(props, willReceiveProps) {\n    var checkedKeys = 'checkedKeys' in props ? props.checkedKeys : willReceiveProps ? [] : props.defaultCheckedKeys;\n    var checkStrictly = this.props.checkStrictly;\n\n    if (checkStrictly) {\n      if (isPlainObject(checkedKeys)) {\n        var _checkedKeys = checkedKeys,\n            checked = _checkedKeys.checked,\n            indeterminate = _checkedKeys.indeterminate;\n        checkedKeys = normalizeToArray(checked);\n        this.indeterminateKeys = normalizeToArray(indeterminate);\n      } else {\n        checkedKeys = normalizeToArray(checkedKeys);\n      }\n    } else {\n      checkedKeys = getAllCheckedKeys(checkedKeys, this._k2n, this._p2n);\n      this.indeterminateKeys = this.getIndeterminateKeys(checkedKeys);\n    }\n\n    return checkedKeys;\n  };\n\n  Tree.prototype.processKey = function processKey(keys, key, add) {\n    var index = keys.indexOf(key);\n\n    if (add && index === -1) {\n      keys.push(key);\n    } else if (!add && index > -1) {\n      keys.splice(index, 1);\n    }\n\n    return keys;\n  };\n\n  Tree.prototype.handleExpand = function handleExpand(expand, key, node) {\n    var _this5 = this;\n\n    var _props = this.props,\n        onExpand = _props.onExpand,\n        loadData = _props.loadData;\n    var expandedKeys = [].concat(this.state.expandedKeys);\n    this.processKey(expandedKeys, key, expand);\n\n    var setExpandedState = function setExpandedState() {\n      if (!('expandedKeys' in _this5.props)) {\n        _this5.setState({\n          expandedKeys: expandedKeys\n        });\n      }\n\n      onExpand(expandedKeys, {\n        expanded: expand,\n        node: node\n      });\n    };\n\n    if (expand && loadData) {\n      return loadData(node).then(setExpandedState);\n    } else {\n      setExpandedState();\n    }\n  };\n\n  Tree.prototype.handleSelect = function handleSelect(select, key, node) {\n    var _props2 = this.props,\n        multiple = _props2.multiple,\n        onSelect = _props2.onSelect;\n    var selectedKeys = [].concat(this.state.selectedKeys);\n\n    if (multiple) {\n      this.processKey(selectedKeys, key, select);\n    } else if (select) {\n      selectedKeys = [key];\n    } else {\n      selectedKeys = [];\n    }\n\n    if (!('selectedKeys' in this.props)) {\n      this.setState({\n        selectedKeys: selectedKeys\n      });\n    }\n\n    onSelect(selectedKeys, {\n      selectedNodes: this.getNodes(selectedKeys),\n      node: node,\n      selected: select\n    });\n  };\n\n  Tree.prototype.handleCheck = function handleCheck(check, key, node) {\n    var _this6 = this;\n\n    var _props3 = this.props,\n        checkStrictly = _props3.checkStrictly,\n        checkedStrategy = _props3.checkedStrategy,\n        onCheck = _props3.onCheck;\n    var checkedKeys = [].concat(this.state.checkedKeys);\n\n    if (checkStrictly) {\n      this.processKey(checkedKeys, key, check);\n\n      var _newCheckedKeys = isPlainObject(this.props.checkedKeys) ? {\n        checked: checkedKeys,\n        indeterminate: this.indeterminateKeys\n      } : checkedKeys;\n\n      onCheck(_newCheckedKeys, {\n        checkedNodes: this.getNodes(checkedKeys),\n        checkedNodesPositions: checkedKeys.map(function (key) {\n          var _k2n$key = _this6._k2n[key],\n              node = _k2n$key.node,\n              pos = _k2n$key.pos;\n          return {\n            node: node,\n            pos: pos\n          };\n        }),\n        node: node,\n        indeterminateKeys: this.indeterminateKeys,\n        checked: check\n      });\n      return;\n    }\n\n    var pos = this._k2n[key].pos;\n    var ps = Object.keys(this._p2n);\n    ps.forEach(function (p) {\n      if (isDescendantOrSelf(pos, p)) {\n        _this6.processKey(checkedKeys, _this6._p2n[p].key, check);\n      }\n    });\n    var currentPos = pos;\n    var nums = pos.split('-');\n\n    for (var i = nums.length; i > 2; i--) {\n      var parentCheck = true;\n      var parentPos = nums.slice(0, i - 1).join('-');\n      var parentKey = this._p2n[parentPos].key;\n      var parentChecked = checkedKeys.indexOf(parentKey) > -1;\n\n      if (!check && !parentChecked) {\n        break;\n      }\n\n      for (var j = 0; j < ps.length; j++) {\n        var p = ps[j];\n\n        if (isSiblingOrSelf(currentPos, p)) {\n          var k = this._p2n[p].key;\n\n          if (checkedKeys.indexOf(k) === -1) {\n            parentCheck = false;\n            break;\n          }\n        }\n      }\n\n      this.processKey(checkedKeys, parentKey, parentCheck);\n      currentPos = parentPos;\n    }\n\n    var indeterminateKeys = this.getIndeterminateKeys(checkedKeys);\n\n    if (!('checkedKeys' in this.props)) {\n      this.setState({\n        checkedKeys: checkedKeys\n      });\n      this.indeterminateKeys = indeterminateKeys;\n    }\n\n    var newCheckedKeys = void 0;\n\n    switch (checkedStrategy) {\n      case 'parent':\n        newCheckedKeys = filterChildKey(checkedKeys, this._k2n);\n        break;\n\n      case 'child':\n        newCheckedKeys = filterParentKey(checkedKeys, this._k2n);\n        break;\n\n      default:\n        newCheckedKeys = checkedKeys;\n        break;\n    }\n\n    onCheck(newCheckedKeys, {\n      checkedNodes: this.getNodes(newCheckedKeys),\n      checkedNodesPositions: newCheckedKeys.map(function (key) {\n        var _k2n$key2 = _this6._k2n[key],\n            node = _k2n$key2.node,\n            pos = _k2n$key2.pos;\n        return {\n          node: node,\n          pos: pos\n        };\n      }),\n      node: node,\n      indeterminateKeys: indeterminateKeys,\n      checked: check\n    });\n  };\n\n  Tree.prototype.getNodeProps = function getNodeProps(key) {\n    var prefix = this.props.prefix;\n    var _state = this.state,\n        expandedKeys = _state.expandedKeys,\n        selectedKeys = _state.selectedKeys,\n        checkedKeys = _state.checkedKeys,\n        dragOverNodeKey = _state.dragOverNodeKey;\n    var pos = this._k2n[key].pos;\n    return {\n      prefix: prefix,\n      root: this,\n      eventKey: key,\n      pos: pos,\n      expanded: expandedKeys.indexOf(key) > -1,\n      selected: selectedKeys.indexOf(key) > -1,\n      checked: checkedKeys.indexOf(key) > -1,\n      indeterminate: this.indeterminateKeys.indexOf(key) > -1,\n      dragOver: dragOverNodeKey === key && this.dropPosition === 0,\n      dragOverGapTop: dragOverNodeKey === key && this.dropPosition === -1,\n      dragOverGapBottom: dragOverNodeKey === key && this.dropPosition === 1\n    };\n  };\n\n  Tree.prototype.getParentNode = function getParentNode(pos) {\n    var parentPos = pos.split('-').slice(0, -1).join('-');\n\n    if (parentPos.length === 1) {\n      return null;\n    }\n\n    return this._p2n[parentPos].node;\n  };\n\n  Tree.prototype.getNodes = function getNodes(keys) {\n    var _this7 = this;\n\n    return keys.map(function (key) {\n      return _this7._k2n[key].node;\n    });\n  };\n\n  Tree.prototype.getIndeterminateKeys = function getIndeterminateKeys(checkedKeys) {\n    var _this8 = this;\n\n    var indeterminateKeys = [];\n    var poss = filterChildKey(checkedKeys, this._k2n).map(function (key) {\n      return _this8._k2n[key].pos;\n    });\n    poss.forEach(function (pos) {\n      var nums = pos.split('-');\n\n      for (var i = nums.length; i > 2; i--) {\n        var parentPos = nums.slice(0, i - 1).join('-');\n        var parentKey = _this8._p2n[parentPos].key;\n\n        if (indeterminateKeys.indexOf(parentKey) === -1) {\n          indeterminateKeys.push(parentKey);\n        }\n      }\n    });\n    return indeterminateKeys;\n  };\n\n  Tree.prototype.handleDragStart = function handleDragStart(e, node) {\n    var _this9 = this;\n\n    var dragNodeKey = node.props.eventKey;\n    this.dragNode = node;\n    this.dragNodesKeys = Object.keys(this._k2n).filter(function (k) {\n      return isDescendantOrSelf(_this9._k2n[dragNodeKey].pos, _this9._k2n[k].pos);\n    });\n    var expandedKeys = this.processKey([].concat(this.state.expandedKeys), dragNodeKey, false);\n    this.setState({\n      expandedKeys: expandedKeys\n    });\n    this.props.onDragStart({\n      event: e,\n      node: node,\n      expandedKeys: expandedKeys\n    });\n  };\n\n  Tree.prototype.handleDragEnter = function handleDragEnter(e, node) {\n    var dragOverNodeKey = node.props.eventKey;\n    this.dropPosition = this.getDropPosition(e, node);\n\n    if (this.dragNode.props.eventKey === dragOverNodeKey && this.dropPosition === 0) {\n      this.setState({\n        dragOverNodeKey: null\n      });\n      return;\n    }\n\n    var expandedKeys = this.processKey([].concat(this.state.expandedKeys), dragOverNodeKey, true);\n    this.setState({\n      dragOverNodeKey: dragOverNodeKey,\n      expandedKeys: expandedKeys\n    });\n    this.props.onDragEnter({\n      event: e,\n      node: node,\n      expandedKeys: expandedKeys\n    });\n  };\n\n  Tree.prototype.getDropPosition = function getDropPosition(e, node) {\n    var labelWrapperNode = node.refs.labelWrapper;\n    var offsetTop = getOffset(labelWrapperNode).top;\n    var offsetHeight = labelWrapperNode.offsetHeight;\n    var pageY = e.pageY;\n    var gapHeight = 2;\n\n    if (pageY > offsetTop + offsetHeight - gapHeight) {\n      return 1;\n    }\n\n    if (pageY < offsetTop + gapHeight) {\n      return -1;\n    }\n\n    return 0;\n  };\n\n  Tree.prototype.handleDragOver = function handleDragOver(e, node) {\n    this.props.onDragOver({\n      event: e,\n      node: node\n    });\n  };\n\n  Tree.prototype.handleDragLeave = function handleDragLeave(e, node) {\n    this.props.onDragLeave({\n      event: e,\n      node: node\n    });\n  };\n\n  Tree.prototype.handleDragEnd = function handleDragEnd(e, node) {\n    this.setState({\n      dragOverNodeKey: null\n    });\n    this.props.onDragEnd({\n      event: e,\n      node: node\n    });\n  };\n\n  Tree.prototype.handleDrop = function handleDrop(e, node) {\n    if (isDescendantOrSelf(this._k2n[this.dragNode.props.eventKey].pos, this._k2n[node.props.eventKey].pos)) {\n      return;\n    }\n\n    this.setState({\n      dragOverNodeKey: null\n    });\n    var params = this.generateDropParams(node);\n    this.props.onDrop(_extends({\n      event: e\n    }, params));\n  };\n\n  Tree.prototype.canDrop = function canDrop(node) {\n    var params = this.generateDropParams(node);\n    return this.props.canDrop(params);\n  };\n\n  Tree.prototype.generateDropParams = function generateDropParams(node) {\n    return {\n      dragNode: this.dragNode,\n      dragNodesKeys: [].concat(this.dragNodesKeys),\n      node: node,\n      dropPosition: this.dropPosition\n    };\n  };\n\n  Tree.prototype.filterTreeNode = function filterTreeNode(node) {\n    return this.props.filterTreeNode.call(this, node);\n  };\n\n  Tree.prototype.renderByDataSource = function renderByDataSource() {\n    var _this10 = this;\n\n    var loop = function loop(data) {\n      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '0';\n      return data.map(function (item, index) {\n        var pos = prefix + '-' + index;\n\n        var _item$key = item.key,\n            key = _item$key === undefined ? pos : _item$key,\n            children = item.children,\n            others = _objectWithoutProperties(item, ['key', 'children']);\n\n        var props = _extends({}, others, _this10.getNodeProps('' + key));\n\n        if (children && children.length) {\n          props.children = loop(children, pos);\n        }\n\n        var node = React.createElement(TreeNode, _extends({\n          key: key\n        }, props));\n        _this10._k2n[key].node = node;\n        return node;\n      });\n    };\n\n    return loop(this.props.dataSource);\n  };\n\n  Tree.prototype.renderByChildren = function renderByChildren() {\n    var _this11 = this;\n\n    var loop = function loop(children) {\n      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '0';\n      return Children.map(children, function (child, index) {\n        var pos = prefix + '-' + index;\n        var key = child.key || pos;\n\n        var props = _this11.getNodeProps('' + key);\n\n        if (child.props.children) {\n          props.children = loop(child.props.children, pos);\n        }\n\n        var node = cloneElement(child, props);\n        _this11._k2n[key].node = node;\n        return node;\n      });\n    };\n\n    return loop(this.props.children);\n  };\n\n  Tree.prototype.render = function render() {\n    var _cx;\n\n    var _props4 = this.props,\n        prefix = _props4.prefix,\n        className = _props4.className,\n        dataSource = _props4.dataSource,\n        showLine = _props4.showLine,\n        isNodeBlock = _props4.isNodeBlock,\n        isLabelBlock = _props4.isLabelBlock;\n    var others = pickOthers(Object.keys(Tree.propTypes), this.props);\n    var newClassName = cx((_cx = {}, _cx[prefix + 'tree'] = true, _cx[prefix + 'label-block'] = isLabelBlock, _cx[prefix + 'node-block'] = isNodeBlock, _cx[prefix + 'node-indent'] = !isNodeBlock, _cx[prefix + 'show-line'] = !isNodeBlock && showLine, _cx[className] = !!className, _cx));\n    return React.createElement('ul', _extends({\n      className: newClassName\n    }, others), dataSource ? this.renderByDataSource() : this.renderByChildren());\n  };\n\n  return Tree;\n}(Component), _class.propTypes = {\n  prefix: PropTypes.string,\n  pure: PropTypes.bool,\n  className: PropTypes.string,\n\n  /**\n   * 树节点\n   */\n  children: PropTypes.node,\n\n  /**\n   * 数据源，该属性优先级高于 children\n   */\n  dataSource: PropTypes.array,\n\n  /**\n   * 是否显示树的线\n   */\n  showLine: PropTypes.bool,\n\n  /**\n   * 是否支持选中节点\n   */\n  selectable: PropTypes.bool,\n\n  /**\n   * （用于受控）当前选中节点 key 的数组\n   */\n  selectedKeys: PropTypes.arrayOf(PropTypes.string),\n\n  /**\n   * （用于非受控）默认选中节点 key 的数组\n   */\n  defaultSelectedKeys: PropTypes.arrayOf(PropTypes.string),\n\n  /**\n   * 选中或取消选中节点时触发的回调函数\n   * @param {Array} selectedKeys 选中节点key的数组\n   * @param {Object} extra 额外参数\n   * @param {Array} extra.selectedNodes 选中节点的数组\n   * @param {Object} extra.node 当前操作的节点\n   * @param {Boolean} extra.selected 当前操作是否是选中\n   */\n  onSelect: PropTypes.func,\n\n  /**\n   * 是否支持多选\n   */\n  multiple: PropTypes.bool,\n\n  /**\n   * 是否支持勾选节点的复选框\n   */\n  checkable: PropTypes.bool,\n\n  /**\n   * （用于受控）当前勾选复选框节点 key 的数组或 `{checked: Array, indeterminate: Array}` 的对象\n   */\n  checkedKeys: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.object]),\n\n  /**\n   * （用于非受控）默认勾选复选框节点 key 的数组\n   */\n  defaultCheckedKeys: PropTypes.arrayOf(PropTypes.string),\n\n  /**\n   * 勾选节点复选框是否完全受控（父子节点选中状态不再关联）\n   */\n  checkStrictly: PropTypes.bool,\n\n  /**\n   * 定义选中时回填的方式\n   * @enumdesc 返回所有选中的节点, 父子节点都选中时只返回父节点, 父子节点都选中时只返回子节点\n   */\n  checkedStrategy: PropTypes.oneOf(['all', 'parent', 'child']),\n\n  /**\n   * 勾选或取消勾选复选框时触发的回调函数\n   * @param {Array} checkedKeys 勾选复选框节点key的数组\n   * @param {Object} extra 额外参数\n   * @param {Array} extra.checkedNodes 勾选复选框节点的数组\n   * @param {Array} extra.checkedNodesPositions 包含有勾选复选框节点和其位置的对象的数组\n   * @param {Array} extra.indeterminateKeys 半选复选框节点 key 的数组\n   * @param {Object} extra.node 当前操作的节点\n   * @param {Boolean} extra.checked 当前操作是否是勾选\n   */\n  onCheck: PropTypes.func,\n\n  /**\n   * （用于受控）当前展开的节点 key 的数组\n   */\n  expandedKeys: PropTypes.arrayOf(PropTypes.string),\n\n  /**\n   * （用于非受控）默认展开的节点 key 的数组\n   */\n  defaultExpandedKeys: PropTypes.arrayOf(PropTypes.string),\n\n  /**\n   * 是否默认展开所有节点\n   */\n  defaultExpandAll: PropTypes.bool,\n\n  /**\n   * 是否自动展开父节点\n   */\n  autoExpandParent: PropTypes.bool,\n\n  /**\n   * 展开或收起节点时触发的回调函数\n   * @param {Array} expandedKeys 展开的节点key的数组\n   * @param {Object} extra 额外参数\n   * @param {Object} extra.node 当前操作的节点\n   * @param {Boolean} extra.expanded 当前操作是否是展开\n   */\n  onExpand: PropTypes.func,\n\n  /**\n   * 是否支持编辑节点内容\n   */\n  editable: PropTypes.bool,\n\n  /**\n   * 编辑节点内容完成时触发的回调函数\n   * @param {String} key 编辑节点的 key\n   * @param {String} label 编辑节点完成时节点的文本\n   * @param {Object} node 当前编辑的节点\n   */\n  onEditFinish: PropTypes.func,\n\n  /**\n   * 是否支持拖拽节点\n   */\n  draggable: PropTypes.bool,\n\n  /**\n   * 开始拖拽节点时触发的回调函数\n   * @param {Object} info 拖拽信息\n   * @param {Object} info.event 事件对象\n   * @param {Object} info.node 拖拽的节点\n   */\n  onDragStart: PropTypes.func,\n\n  /**\n   * 拖拽节点进入目标节点时触发的回调函数\n   * @param {Object} info 拖拽信息\n   * @param {Object} info.event 事件对象\n   * @param {Object} info.node 目标节点\n   * @param {Array} info.expandedKeys 当前展开的节点key的数组\n   */\n  onDragEnter: PropTypes.func,\n\n  /**\n   * 拖拽节点在目标节点上移动的时候触发的回调函数\n   * @param {Object} info 拖拽信息\n   * @param {Object} info.event 事件对象\n   * @param {Object} info.node 目标节点\n   */\n  onDragOver: PropTypes.func,\n\n  /**\n   * 拖拽节点离开目标节点时触发的回调函数\n   * @param {Object} info 拖拽信息\n   * @param {Object} info.event 事件对象\n   * @param {Object} info.node 目标节点\n   */\n  onDragLeave: PropTypes.func,\n\n  /**\n   * 拖拽节点拖拽结束时触发的回调函数\n   * @param {Object} info 拖拽信息\n   * @param {Object} info.event 事件对象\n   * @param {Object} info.node 目标节点\n   */\n  onDragEnd: PropTypes.func,\n\n  /**\n   * 拖拽节点放入目标节点内或前后触发的回调函数\n   * @param {Object} info 拖拽信息\n   * @param {Object} info.event 事件对象\n   * @param {Object} info.node 目标节点\n   * @param {Object} info.dragNode 拖拽的节点\n   * @param {Array} info.dragNodesKeys 拖拽的节点和其子节点 key 的数组\n   * @param {Number} info.dropPosition 放置位置，-1代表当前节点前，0代表当前节点里，1代表当前节点后\n   */\n  onDrop: PropTypes.func,\n\n  /**\n   * 节点是否可被作为拖拽的目标节点\n   * @param {Object} info 拖拽信息\n   * @param {Object} info.node 目标节点\n   * @param {Object} info.dragNode 拖拽的节点\n   * @param {Array} info.dragNodesKeys 拖拽的节点和其子节点 key 的数组\n   * @param {Number} info.dropPosition 放置位置，-1代表当前节点前，0代表当前节点里，1代表当前节点后\n   * @return {Boolean} 是否可以被当作目标节点\n   */\n  canDrop: PropTypes.func,\n\n  /**\n   * 异步加载数据的函数\n   * @param {Object} node 被点击展开的节点\n   */\n  loadData: PropTypes.func,\n\n  /**\n   * 按需筛选高亮节点\n   * @param {Object} node 待筛选的节点\n   * @return {Boolean} 是否被筛选中\n   */\n  filterTreeNode: PropTypes.func,\n\n  /**\n   * 右键点击节点时触发的回调函数\n   * @param {Object} info 信息对象\n   * @param {Object} info.event 事件对象\n   * @param {Object} info.node 点击的节点\n   */\n  onRightClick: PropTypes.func,\n\n  /**\n   * 设置节点是否占满剩余空间，一般用于统一在各节点右侧添加元素(借助 flex 实现，暂时只支持 ie10+)\n   */\n  isLabelBlock: PropTypes.bool,\n\n  /**\n   * 设置节点是否占满一行\n   */\n  isNodeBlock: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n\n  /**\n   * 是否开启展开收起动画\n   */\n  animation: PropTypes.bool\n}, _class.defaultProps = {\n  prefix: 'next-',\n  pure: false,\n  showLine: false,\n  selectable: true,\n  editable: false,\n  multiple: false,\n  checkable: false,\n  checkStrictly: false,\n  checkedStrategy: 'all',\n  draggable: false,\n  autoExpandParent: true,\n  defaultExpandAll: false,\n  defaultExpandedKeys: [],\n  defaultCheckedKeys: [],\n  defaultSelectedKeys: [],\n  onExpand: function onExpand() {},\n  onCheck: function onCheck() {},\n  onSelect: function onSelect() {},\n  onDragStart: function onDragStart() {},\n  onDragEnter: function onDragEnter() {},\n  onDragOver: function onDragOver() {},\n  onDragLeave: function onDragLeave() {},\n  onDragEnd: function onDragEnd() {},\n  onDrop: function onDrop() {},\n  canDrop: function canDrop() {\n    return true;\n  },\n  onEditFinish: function onEditFinish() {},\n  onRightClick: function onRightClick() {},\n  isLabelBlock: false,\n  isNodeBlock: false,\n  animation: true\n}, _temp);\nTree.displayName = 'Tree';\nexport default ConfigProvider.config(Tree);","map":null,"metadata":{},"sourceType":"module"}