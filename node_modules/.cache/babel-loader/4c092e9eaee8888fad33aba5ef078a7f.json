{"ast":null,"code":"import _extends from 'babel-runtime/helpers/extends';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\n\nvar _class, _temp;\n\nimport React, { Component, Children } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport classnames from 'classnames';\nimport { dom, events, func, support, focus, KEYCODE, guid } from '../util';\nimport overlayManager from './manager';\nimport Gateway from './gateway';\nimport Position from './position';\nimport findNode from './utils/find-node';\nvar saveLastFocusNode = focus.saveLastFocusNode,\n    getFocusNodeList = focus.getFocusNodeList,\n    backLastFocusNode = focus.backLastFocusNode;\nvar makeChain = func.makeChain,\n    noop = func.noop,\n    bindCtx = func.bindCtx;\n\nvar isScrollDisplay = function isScrollDisplay(element) {\n  try {\n    var scrollbarStyle = window.getComputedStyle(element, '::-webkit-scrollbar');\n    return !scrollbarStyle || scrollbarStyle.getPropertyValue('display') !== 'none';\n  } catch (e) {// ignore error for firefox\n  }\n\n  return true;\n};\n\nvar hasScroll = function hasScroll() {\n  var doc = document.documentElement;\n  return doc.scrollHeight > doc.clientHeight && dom.scrollbar().width > 0 && isScrollDisplay(document.documentElement) && isScrollDisplay(document.body);\n};\n\nvar prefixes = ['-webkit-', '-moz-', '-o-', 'ms-', ''];\n\nvar getStyleProperty = function getStyleProperty(node, name) {\n  var style = window.getComputedStyle(node);\n  var ret = '';\n\n  for (var i = 0; i < prefixes.length; i++) {\n    ret = style.getPropertyValue(prefixes[i] + name);\n\n    if (ret) {\n      break;\n    }\n  }\n\n  return ret;\n};\n\nvar modals = [];\nvar bodyOverflowY = void 0,\n    bodyPaddingRight = void 0;\n/**\n * Overlay\n * */\n\nvar Overlay = (_temp = _class = function (_Component) {\n  _inherits(Overlay, _Component);\n\n  function Overlay(props) {\n    _classCallCheck(this, Overlay);\n\n    var _this = _possibleConstructorReturn(this, _Component.call(this, props));\n\n    _this.saveContentRef = function (ref) {\n      _this.contentRef = ref;\n    };\n\n    _this.saveGatewayRef = function (ref) {\n      _this.gatewayRef = ref;\n    };\n\n    _this.state = {\n      visible: props.visible,\n      status: 'none',\n      animation: _this.getAnimation(props)\n    };\n    _this.lastAlign = props.align;\n    bindCtx(_this, ['handlePosition', 'handleAnimateEnd', 'handleDocumentKeyDown', 'handleDocumentClick', 'handleMaskClick', 'beforeOpen', 'beforeClose']);\n    _this.timeoutMap = {};\n    return _this;\n  }\n\n  Overlay.prototype.componentWillMount = function componentWillMount() {\n    if (this.props.visible) {\n      this.beforeOpen();\n      this.props.beforeOpen();\n\n      if (this.state.animation && support.animation) {\n        this.enter();\n      }\n    }\n  };\n\n  Overlay.prototype.componentDidMount = function componentDidMount() {\n    this.componentDidUpdate({\n      visible: false\n    });\n    this.addDocumentEvents();\n    overlayManager.addOverlay(this);\n\n    if (this.state.visible) {\n      this._isMounted = true;\n    }\n  };\n\n  Overlay.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    if (!this._isMounted && nextProps.visible) {\n      this._isMounted = true;\n    }\n\n    var willOpen = !this.props.visible && nextProps.visible;\n    var willClose = this.props.visible && !nextProps.visible;\n\n    if (willOpen) {\n      this.beforeOpen();\n      nextProps.beforeOpen();\n    } else if (willClose) {\n      this.beforeClose();\n      nextProps.beforeClose();\n    }\n\n    if (nextProps.animation || nextProps.animation === false) {\n      this.setState({\n        animation: nextProps.animation\n      });\n    }\n\n    if (nextProps.animation !== false && support.animation) {\n      if (willOpen) {\n        this.enter();\n      } else if (willClose) {\n        this.leave();\n      }\n    } else {\n      this.setState({\n        visible: nextProps.visible\n      });\n    }\n  };\n\n  Overlay.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var _this2 = this;\n\n    var open = !prevProps.visible && this.props.visible;\n    var close = prevProps.visible && !this.props.visible;\n\n    if (this.state.animation && support.animation) {\n      if (open || close) {\n        this.addAnimationEvents();\n      }\n    } else {\n      var wrapperNode = this.getWrapperNode();\n\n      if (open) {\n        setTimeout(function () {\n          _this2.props.onOpen();\n\n          _this2.props.afterOpen();\n\n          dom.addClass(wrapperNode, 'opened');\n          overlayManager.addOverlay(_this2);\n        });\n      } else if (close) {\n        this.props.onClose();\n        this.props.afterClose();\n        dom.removeClass(wrapperNode, 'opened');\n        overlayManager.removeOverlay(this);\n      }\n\n      this.setFocusNode();\n    }\n  };\n\n  Overlay.prototype.componentWillUnmount = function componentWillUnmount() {\n    this._isDestroyed = true;\n    this._isMounted = false;\n    overlayManager.removeOverlay(this);\n    this.removeDocumentEvents();\n\n    if (this.focusTimeout) {\n      clearTimeout(this.focusTimeout);\n    }\n\n    if (this._animation) {\n      this._animation.off();\n\n      this._animation = null;\n    }\n\n    this.beforeClose();\n  };\n\n  Overlay.prototype.getAnimation = function getAnimation(props) {\n    if (props.animation === false) {\n      return false;\n    }\n\n    if (props.animation) {\n      return props.animation;\n    }\n\n    return this.getAnimationByAlign(props.align);\n  };\n\n  Overlay.prototype.getAnimationByAlign = function getAnimationByAlign(align) {\n    switch (align[0]) {\n      case 't':\n        return {\n          in: 'expandInDown',\n          out: 'expandOutUp'\n        };\n\n      case 'b':\n        return {\n          in: 'expandInUp',\n          out: 'expandOutDown'\n        };\n\n      default:\n        return {\n          in: 'expandInDown',\n          out: 'expandOutUp'\n        };\n    }\n  };\n\n  Overlay.prototype.addAnimationEvents = function addAnimationEvents() {\n    var _this3 = this;\n\n    setTimeout(function () {\n      var node = _this3.getContentNode();\n\n      if (node) {\n        var id = guid();\n        _this3._animation = events.on(node, support.animation.end, _this3.handleAnimateEnd.bind(_this3, id));\n        var animationDelay = parseFloat(getStyleProperty(node, 'animation-delay')) || 0;\n        var animationDuration = parseFloat(getStyleProperty(node, 'animation-duration')) || 0;\n        var time = animationDelay + animationDuration;\n\n        if (time) {\n          _this3.timeoutMap[id] = setTimeout(function () {\n            _this3.handleAnimateEnd(id);\n          }, time * 1000 + 200);\n        }\n      }\n    });\n  };\n\n  Overlay.prototype.handlePosition = function handlePosition(config) {\n    var align = config.align.join(' ');\n\n    if (!('animation' in this.props) && this.props.needAdjust && this.lastAlign !== align) {\n      this.setState({\n        animation: this.getAnimationByAlign(align)\n      });\n    }\n\n    this.lastAlign = align;\n  };\n\n  Overlay.prototype.handleAnimateEnd = function handleAnimateEnd(id) {\n    if (this.timeoutMap[id]) {\n      clearTimeout(this.timeoutMap[id]);\n    }\n\n    delete this.timeoutMap[id];\n\n    if (this._animation) {\n      this._animation.off();\n\n      this._animation = null;\n    }\n\n    if (!this._isMounted) {\n      return;\n    }\n\n    if (this.state.status === 'leaving') {\n      this.setState({\n        visible: false,\n        status: 'none'\n      });\n      this.onLeaved();\n    } else if (this.state.status === 'entering') {\n      this.setState({\n        status: 'none'\n      });\n      this.onEntered();\n    }\n  };\n\n  Overlay.prototype.enter = function enter() {\n    var _this4 = this;\n\n    this.setState({\n      visible: true,\n      status: 'entering'\n    }, function () {\n      // NOTE: setState callback (second argument) now fires immediately after componentDidMount / componentDidUpdate instead of after all components have rendered.\n      setTimeout(function () {\n        if (!_this4._isDestroyed) {\n          _this4.onEntering();\n        }\n      });\n    });\n  };\n\n  Overlay.prototype.leave = function leave() {\n    this.setState({\n      status: 'leaving'\n    });\n    this.onLeaving();\n  };\n\n  Overlay.prototype.onEntering = function onEntering() {\n    var wrapperNode = this.getWrapperNode();\n    dom.addClass(wrapperNode, 'opened');\n    this.props.onOpen();\n  };\n\n  Overlay.prototype.onLeaving = function onLeaving() {\n    var wrapperNode = this.getWrapperNode();\n    dom.removeClass(wrapperNode, 'opened');\n    this.props.onClose();\n  };\n\n  Overlay.prototype.onEntered = function onEntered() {\n    overlayManager.addOverlay(this);\n    this.setFocusNode();\n    this.props.afterOpen();\n  };\n\n  Overlay.prototype.onLeaved = function onLeaved() {\n    overlayManager.removeOverlay(this);\n    this.setFocusNode();\n    this.props.afterClose();\n  };\n\n  Overlay.prototype.beforeOpen = function beforeOpen() {\n    if (this.props.disableScroll) {\n      if (modals.length === 0) {\n        var style = {\n          overflowY: 'hidden'\n        };\n        var body = document.body;\n        bodyOverflowY = body.style.overflowY;\n\n        if (hasScroll()) {\n          bodyPaddingRight = body.style.paddingRight;\n          style.paddingRight = dom.getStyle(body, 'paddingRight') + dom.scrollbar().width + 'px';\n        }\n\n        dom.setStyle(body, style);\n      }\n\n      modals.push(this);\n    }\n  };\n\n  Overlay.prototype.beforeClose = function beforeClose() {\n    if (this.props.disableScroll) {\n      var index = modals.indexOf(this);\n\n      if (index > -1) {\n        if (modals.length === 1) {\n          var style = {\n            overflowY: bodyOverflowY\n          };\n\n          if (hasScroll()) {\n            style.paddingRight = bodyPaddingRight;\n          }\n\n          dom.setStyle(document.body, style);\n          bodyOverflowY = undefined;\n          bodyPaddingRight = undefined;\n        }\n\n        modals.splice(index, 1);\n      }\n    }\n  };\n\n  Overlay.prototype.setFocusNode = function setFocusNode() {\n    var _this5 = this;\n\n    if (!this.props.autoFocus) {\n      return;\n    }\n\n    if (this.state.visible && !this._hasFocused) {\n      saveLastFocusNode(); // 这个时候很可能上一个弹层的关闭事件还未触发，导致焦点已经回到触发的元素\n      // 这里延时处理一下，延时的时间为 document.click 捕获触发的延时时间\n\n      this.focusTimeout = setTimeout(function () {\n        var node = _this5.getContentNode();\n\n        if (node) {\n          var focusNodeList = getFocusNodeList(node);\n\n          if (focusNodeList.length) {\n            focusNodeList[0].focus();\n          }\n\n          _this5._hasFocused = true;\n        }\n      }, 100);\n    } else if (!this.state.visible && this._hasFocused) {\n      backLastFocusNode();\n      this._hasFocused = false;\n    }\n  };\n\n  Overlay.prototype.getContent = function getContent() {\n    return this.contentRef;\n  };\n\n  Overlay.prototype.getContentNode = function getContentNode() {\n    return findDOMNode(this.contentRef);\n  };\n\n  Overlay.prototype.getWrapperNode = function getWrapperNode() {\n    return this.gatewayRef ? this.gatewayRef.getChildNode() : null;\n  };\n\n  Overlay.prototype.addDocumentEvents = function addDocumentEvents() {\n    if (this.props.canCloseByEsc) {\n      this._keydownEvents = events.on(document, 'keydown', this.handleDocumentKeyDown);\n    }\n\n    if (this.props.canCloseByOutSideClick) {\n      this._clickEvents = events.on(document, 'click', this.handleDocumentClick);\n    }\n  };\n\n  Overlay.prototype.removeDocumentEvents = function removeDocumentEvents() {\n    if (this._keydownEvents) {\n      this._keydownEvents.off();\n\n      this._keydownEvents = null;\n    }\n\n    if (this._clickEvents) {\n      this._clickEvents.off();\n\n      this._clickEvents = null;\n    }\n  };\n\n  Overlay.prototype.handleDocumentKeyDown = function handleDocumentKeyDown(e) {\n    if (this.state.visible && e.keyCode === KEYCODE.ESC && overlayManager.isCurrentOverlay(this)) {\n      this.props.onRequestClose('keyboard', e);\n    }\n  };\n\n  Overlay.prototype.handleDocumentClick = function handleDocumentClick(e) {\n    var _this6 = this;\n\n    if (this.state.visible) {\n      var safeNode = this.props.safeNode;\n      var safeNodes = Array.isArray(safeNode) ? [].concat(safeNode) : [safeNode];\n      safeNodes.unshift(function () {\n        return _this6.getWrapperNode();\n      });\n\n      for (var i = 0; i < safeNodes.length; i++) {\n        var node = findNode(safeNodes[i], this.props); // HACK: 如果触发点击的节点是弹层内部的节点，并且在被点击后立即销毁，那么此时无法使用 node.contains(e.target)\n        // 来判断此时点击的节点是否是弹层内部的节点，额外判断\n\n        if (node && (node === e.target || node.contains(e.target) || e.target !== document && !document.documentElement.contains(e.target))) {\n          return;\n        }\n      }\n\n      this.props.onRequestClose('docClick', e);\n    }\n  };\n\n  Overlay.prototype.handleMaskClick = function handleMaskClick(e) {\n    if (this.props.canCloseByMask) {\n      this.props.onRequestClose('maskClick', e);\n    }\n  }; // 兼容过去的用法: this.popupRef.getInstance().overlay.getInstance().getContentNode()\n\n\n  Overlay.prototype.getInstance = function getInstance() {\n    return this;\n  };\n\n  Overlay.prototype.render = function render() {\n    var _props = this.props,\n        prefix = _props.prefix,\n        className = _props.className,\n        style = _props.style,\n        propChildren = _props.children,\n        target = _props.target,\n        align = _props.align,\n        offset = _props.offset,\n        container = _props.container,\n        hasMask = _props.hasMask,\n        needAdjust = _props.needAdjust,\n        beforePosition = _props.beforePosition,\n        onPosition = _props.onPosition,\n        wrapperStyle = _props.wrapperStyle,\n        rtl = _props.rtl,\n        propShouldUpdatePosition = _props.shouldUpdatePosition,\n        cache = _props.cache,\n        wrapperClassName = _props.wrapperClassName,\n        onMaskMouseEnter = _props.onMaskMouseEnter,\n        onMaskMouseLeave = _props.onMaskMouseLeave;\n    var _state = this.state,\n        stateVisible = _state.visible,\n        status = _state.status,\n        animation = _state.animation;\n    var children = stateVisible || cache && this._isMounted ? propChildren : null;\n\n    if (children) {\n      var _classnames;\n\n      var child = Children.only(children);\n      var childClazz = classnames((_classnames = {}, _classnames[prefix + 'overlay-inner'] = true, _classnames[animation.in] = status === 'entering', _classnames[animation.out] = status === 'leaving', _classnames[child.props.className] = !!child.props.className, _classnames[className] = !!className, _classnames));\n\n      if (typeof child.ref === 'string') {\n        throw new Error('Can not set ref by string in Overlay, use function instead.');\n      }\n\n      children = React.cloneElement(child, {\n        className: childClazz,\n        style: _extends({}, child.props.style, style),\n        ref: makeChain(this.saveContentRef, child.ref),\n        'aria-hidden': !stateVisible && cache && this._isMounted\n      });\n\n      if (align) {\n        var shouldUpdatePosition = status === 'leaving' ? false : propShouldUpdatePosition;\n        children = React.createElement(Position, {\n          children: children,\n          target: target,\n          align: align,\n          offset: offset,\n          needAdjust: needAdjust,\n          beforePosition: beforePosition,\n          onPosition: makeChain(this.handlePosition, onPosition),\n          shouldUpdatePosition: shouldUpdatePosition,\n          rtl: rtl\n        });\n      }\n\n      var wrapperClazz = classnames([prefix + 'overlay-wrapper', wrapperClassName]);\n\n      var newWrapperStyle = _extends({}, {\n        display: stateVisible ? '' : 'none'\n      }, wrapperStyle);\n\n      children = React.createElement('div', {\n        className: wrapperClazz,\n        style: newWrapperStyle,\n        dir: rtl ? 'rtl' : undefined\n      }, hasMask ? React.createElement('div', {\n        className: prefix + 'overlay-backdrop',\n        onClick: this.handleMaskClick,\n        onMouseEnter: onMaskMouseEnter,\n        onMouseLeave: onMaskMouseLeave,\n        dir: rtl ? 'rtl' : undefined\n      }) : null, children);\n    }\n\n    return React.createElement(Gateway, _extends({\n      container: container,\n      target: target,\n      children: children\n    }, {\n      ref: this.saveGatewayRef\n    }));\n  };\n\n  return Overlay;\n}(Component), _class.propTypes = {\n  prefix: PropTypes.string,\n  pure: PropTypes.bool,\n  rtl: PropTypes.bool,\n  className: PropTypes.string,\n  style: PropTypes.object,\n\n  /**\n   * 弹层内容\n   */\n  children: PropTypes.any,\n\n  /**\n   * 是否显示弹层\n   */\n  visible: PropTypes.bool,\n\n  /**\n   * 弹层请求关闭时触发事件的回调函数\n   * @param {String} type 弹层关闭的来源\n   * @param {Object} e DOM 事件\n   */\n  onRequestClose: PropTypes.func,\n\n  /**\n   * 弹层定位的参照元素\n   */\n  target: PropTypes.any,\n\n  /**\n   * 弹层相对于参照元素的定位, 详见开发指南的[定位部分](#定位)\n   */\n  align: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\n\n  /**\n   * 弹层相对于参照元素定位的微调\n   */\n  offset: PropTypes.array,\n\n  /**\n   * 渲染组件的容器，如果是函数需要返回 ref，如果是字符串则是该 DOM 的 id，也可以直接传入 DOM 节点\n   */\n  container: PropTypes.any,\n\n  /**\n   * 是否显示遮罩\n   */\n  hasMask: PropTypes.bool,\n\n  /**\n   * 是否支持 esc 按键关闭弹层\n   */\n  canCloseByEsc: PropTypes.bool,\n\n  /**\n   * 点击弹层外的区域是否关闭弹层，不显示遮罩时生效\n   */\n  canCloseByOutSideClick: PropTypes.bool,\n\n  /**\n   * 点击遮罩区域是否关闭弹层，显示遮罩时生效\n   */\n  canCloseByMask: PropTypes.bool,\n\n  /**\n   * 弹层打开前触发事件的回调函数\n   */\n  beforeOpen: PropTypes.func,\n\n  /**\n   * 弹层打开时触发事件的回调函数\n   */\n  onOpen: PropTypes.func,\n\n  /**\n   * 弹层打开后触发事件的回调函数, 如果有动画，则在动画结束后触发\n   */\n  afterOpen: PropTypes.func,\n\n  /**\n   * 弹层关闭前触发事件的回调函数\n   */\n  beforeClose: PropTypes.func,\n\n  /**\n   * 弹层关闭时触发事件的回调函数\n   */\n  onClose: PropTypes.func,\n\n  /**\n   * 弹层关闭后触发事件的回调函数, 如果有动画，则在动画结束后触发\n   */\n  afterClose: PropTypes.func,\n\n  /**\n   * 弹层定位完成前触发的事件\n   */\n  beforePosition: PropTypes.func,\n\n  /**\n   * 弹层定位完成时触发的事件\n   * @param {Object} config 定位的参数\n   * @param {Array} config.align 对齐方式，如 ['cc', 'cc']（如果开启 needAdjust，可能和预先设置的 align 不同）\n   * @param {Number} config.top 距离视口顶部距离\n   * @param {Number} config.left 距离视口左侧距离\n   * @param {Object} node 定位参照的容器节点\n   */\n  onPosition: PropTypes.func,\n\n  /**\n   * 是否在每次弹层重新渲染后强制更新定位信息，一般用于弹层内容区域大小发生变化时，仍需保持原来的定位方式\n   */\n  shouldUpdatePosition: PropTypes.bool,\n\n  /**\n   * 弹层打开时是否让其中的元素自动获取焦点\n   */\n  autoFocus: PropTypes.bool,\n\n  /**\n   * 当弹层由于页面滚动等情况不在可视区域时，是否自动调整定位以出现在可视区域\n   */\n  needAdjust: PropTypes.bool,\n\n  /**\n   * 是否禁用页面滚动\n   */\n  disableScroll: PropTypes.bool,\n\n  /**\n   * 隐藏时是否保留子节点\n   */\n  cache: PropTypes.bool,\n\n  /**\n   * 安全节点，当点击 document 的时候，如果包含该节点则不会关闭弹层，如果是函数需要返回 ref，如果是字符串则是该 DOM 的 id，也可以直接传入 DOM 节点，或者以上值组成的数组\n   */\n  safeNode: PropTypes.any,\n\n  /**\n   * 弹层的根节点的样式类\n   */\n  wrapperClassName: PropTypes.string,\n\n  /**\n   * 弹层的根节点的内联样式\n   */\n  wrapperStyle: PropTypes.object,\n\n  /**\n   * 配置动画的播放方式，支持 { in: 'enter-class', out: 'leave-class' } 的对象参数，如果设置为 false，则不播放动画\n   * @default { in: 'expandInDown', out: 'expandOutUp' }\n   */\n  animation: PropTypes.oneOfType([PropTypes.object, PropTypes.bool]),\n  onMaskMouseEnter: PropTypes.func,\n  onMaskMouseLeave: PropTypes.func\n}, _class.defaultProps = {\n  prefix: 'next-',\n  pure: false,\n  visible: false,\n  onRequestClose: noop,\n  target: Position.VIEWPORT,\n  align: 'tl bl',\n  offset: [0, 0],\n  hasMask: false,\n  canCloseByEsc: true,\n  canCloseByOutSideClick: true,\n  canCloseByMask: true,\n  beforeOpen: noop,\n  onOpen: noop,\n  afterOpen: noop,\n  beforeClose: noop,\n  onClose: noop,\n  afterClose: noop,\n  beforePosition: noop,\n  onPosition: noop,\n  onMaskMouseEnter: noop,\n  onMaskMouseLeave: noop,\n  shouldUpdatePosition: false,\n  autoFocus: false,\n  needAdjust: true,\n  disableScroll: false,\n  cache: false\n}, _temp);\nOverlay.displayName = 'Overlay';\nexport { Overlay as default };","map":null,"metadata":{},"sourceType":"module"}