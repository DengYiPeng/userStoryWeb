{"ast":null,"code":"import _classCallCheck from 'babel-runtime/helpers/classCallCheck';\n\nvar _class, _temp;\n\nimport { dom } from '../../util';\nvar VIEWPORT = 'viewport'; // IE8 not support pageXOffset\n\nvar getPageX = function getPageX() {\n  return window.pageXOffset || document.documentElement.scrollLeft;\n};\n\nvar getPageY = function getPageY() {\n  return window.pageYOffset || document.documentElement.scrollTop;\n};\n/**\n * @private get element rect\n * @param       {Element} elem\n * @return      {Object}\n */\n\n\nfunction _getElementRect(elem) {\n  var offsetTop = 0,\n      offsetLeft = 0;\n  var offsetHeight = elem.offsetHeight;\n  var offsetWidth = elem.offsetWidth;\n\n  do {\n    if (!isNaN(elem.offsetTop)) {\n      offsetTop += elem.offsetTop;\n    }\n\n    if (!isNaN(elem.offsetLeft)) {\n      offsetLeft += elem.offsetLeft;\n    }\n  } while ((elem = elem.offsetParent) !== null);\n\n  return {\n    top: offsetTop - (document.documentElement.scrollTop || document.body.scrollTop),\n    left: offsetLeft - (document.documentElement.scrollLeft || document.body.scrollLeft),\n    height: offsetHeight,\n    width: offsetWidth\n  };\n}\n/**\n * @private get viewport size\n * @return {Object}\n */\n\n\nfunction _getViewportSize() {\n  return {\n    width: document.documentElement.clientWidth,\n    height: document.documentElement.clientHeight\n  };\n}\n\nvar Position = (_temp = _class = function () {\n  function Position(props) {\n    _classCallCheck(this, Position);\n\n    this.pinElement = props.pinElement;\n    this.baseElement = props.baseElement;\n    this.align = props.align || 'tl tl';\n    this.offset = props.offset || [0, 0];\n    this.needAdjust = props.needAdjust || false;\n    this.isRtl = props.isRtl || false;\n  }\n  /**\n   * @public static place method\n   * @param  {Object}       props\n   *     @param  {DOM}      props.pinElement\n   *     @param  {DOM}      props.baseElement\n   *     @param  {String}   props.align\n   *     @param  {Number}   props.offset\n   *     @param  {Boolean}  props.needAdjust\n   *     @param  {Boolean}  props.isRtl\n   * @return {Position}\n   */\n\n\n  Position.prototype.setPosition = function setPosition() {\n    var pinElement = this.pinElement;\n    var baseElement = this.baseElement;\n\n    var expectedAlign = this._getExpectedAlign();\n\n    var isPinFixed = void 0,\n        isBaseFixed = void 0,\n        firstPositionResult = void 0;\n\n    if (pinElement === VIEWPORT) {\n      return;\n    }\n\n    if (dom.getStyle(pinElement, 'position') !== 'fixed') {\n      dom.setStyle(pinElement, 'position', 'absolute');\n      isPinFixed = false;\n    } else {\n      isPinFixed = true;\n    }\n\n    if (baseElement === VIEWPORT || dom.getStyle(baseElement, 'position') !== 'fixed') {\n      isBaseFixed = false;\n    } else {\n      isBaseFixed = true;\n    } // 根据期望的定位\n\n\n    for (var i = 0; i < expectedAlign.length; i++) {\n      var align = expectedAlign[i];\n\n      var pinElementPoints = this._normalizePosition(pinElement, align.split(' ')[0], isPinFixed);\n\n      var baseElementPoints = this._normalizePosition(baseElement, align.split(' ')[1], isPinFixed);\n\n      var pinElementParentOffset = this._getParentOffset(pinElement);\n\n      var baseElementOffset = isPinFixed && isBaseFixed ? this._getLeftTop(baseElement) : baseElementPoints.offset();\n      var top = baseElementOffset.top + baseElementPoints.y - pinElementParentOffset.top - pinElementPoints.y;\n      var left = baseElementOffset.left + baseElementPoints.x - pinElementParentOffset.left - pinElementPoints.x;\n\n      this._setPinElementPostion(pinElement, {\n        left: left,\n        top: top\n      }, this.offset);\n\n      if (!firstPositionResult) {\n        firstPositionResult = {\n          left: left,\n          top: top\n        };\n      }\n\n      if (this._isInViewport(pinElement)) {\n        return align;\n      }\n    }\n\n    var inViewportLeft = this._makeElementInViewport(pinElement, firstPositionResult.left, 'Left', isPinFixed);\n\n    var inViewportTop = this._makeElementInViewport(pinElement, firstPositionResult.top, 'Top', isPinFixed);\n\n    this._setPinElementPostion(pinElement, {\n      left: inViewportLeft,\n      top: inViewportTop\n    });\n\n    return expectedAlign[0];\n  };\n\n  Position.prototype._getParentOffset = function _getParentOffset(element) {\n    var parent = element.offsetParent || document.documentElement;\n    var offset = void 0;\n\n    if (parent === document.body && dom.getStyle(parent, 'position') === 'static') {\n      offset = {\n        top: 0,\n        left: 0\n      };\n    } else {\n      offset = this._getElementOffset(parent);\n    }\n\n    offset.top += parseFloat(dom.getStyle(parent, 'border-top-width'), 10);\n    offset.left += parseFloat(dom.getStyle(parent, 'border-left-width'), 10);\n    offset.offsetParent = parent;\n    return offset;\n  };\n\n  Position.prototype._makeElementInViewport = function _makeElementInViewport(pinElement, number, type, isPinFixed) {\n    var result = number;\n    var docElement = document.documentElement;\n    var offsetParent = pinElement.offsetParent || document.documentElement;\n\n    if (result < 0) {\n      if (isPinFixed) {\n        result = 0;\n      } else if (offsetParent === document.body && dom.getStyle(offsetParent, 'position') === 'static') {\n        // Only when div's offsetParent is document.body, we set new position result.\n        result = Math.max(docElement['scroll' + type], document.body['scroll' + type]);\n      }\n    }\n\n    return result;\n  };\n\n  Position.prototype._normalizePosition = function _normalizePosition(element, align, isPinFixed) {\n    var points = this._normalizeElement(element, isPinFixed);\n\n    this._normalizeXY(points, align);\n\n    return points;\n  };\n\n  Position.prototype._normalizeXY = function _normalizeXY(points, align) {\n    var x = align.split('')[1];\n    var y = align.split('')[0];\n    points.x = this._xyConverter(x, points, 'width');\n    points.y = this._xyConverter(y, points, 'height');\n    return points;\n  };\n\n  Position.prototype._xyConverter = function _xyConverter(align, points, type) {\n    var res = align.replace(/t|l/gi, '0%').replace(/c/gi, '50%').replace(/b|r/gi, '100%').replace(/(\\d+)%/gi, function (m, d) {\n      return points.size()[type] * (d / 100);\n    });\n    return parseFloat(res, 10) || 0;\n  };\n\n  Position.prototype._getLeftTop = function _getLeftTop(element) {\n    return {\n      left: parseFloat(dom.getStyle(element, 'left')) || 0,\n      top: parseFloat(dom.getStyle(element, 'top')) || 0\n    };\n  };\n\n  Position.prototype._normalizeElement = function _normalizeElement(element, isPinFixed) {\n    var _this = this;\n\n    var result = {\n      element: element,\n      x: 0,\n      y: 0\n    },\n        isViewport = element === VIEWPORT,\n        docElement = document.documentElement;\n\n    result.offset = function () {\n      if (isPinFixed) {\n        return {\n          left: 0,\n          top: 0\n        };\n      } else if (isViewport) {\n        return {\n          left: getPageX(),\n          top: getPageY()\n        };\n      } else {\n        return _this._getElementOffset(element);\n      }\n    };\n\n    result.size = function () {\n      if (isViewport) {\n        return {\n          width: docElement.clientWidth,\n          height: docElement.clientHeight\n        };\n      } else {\n        return {\n          width: element.offsetWidth,\n          height: element.offsetHeight\n        };\n      }\n    };\n\n    return result;\n  };\n\n  Position.prototype._getElementOffset = function _getElementOffset(element) {\n    var rect = element.getBoundingClientRect();\n    var docElement = document.documentElement;\n    var body = document.body;\n    var docClientLeft = docElement.clientLeft || body.clientLeft || 0;\n    var docClientTop = docElement.clientTop || body.clientTop || 0;\n    return {\n      left: rect.left + (getPageX() - docClientLeft),\n      top: rect.top + (getPageY() - docClientTop)\n    };\n  }; // According to the location of the overflow to calculate the desired positioning\n\n\n  Position.prototype._getExpectedAlign = function _getExpectedAlign() {\n    var align = this.isRtl ? this._replaceAlignDir(this.align, /l|r/g, {\n      l: 'r',\n      r: 'l'\n    }) : this.align;\n    var expectedAlign = [align];\n\n    if (this.needAdjust) {\n      if (/t|b/g.test(align)) {\n        expectedAlign.push(this._replaceAlignDir(align, /t|b/g, {\n          t: 'b',\n          b: 't'\n        }));\n      }\n\n      if (/l|r/g.test(align)) {\n        expectedAlign.push(this._replaceAlignDir(align, /l|r/g, {\n          l: 'r',\n          r: 'l'\n        }));\n      }\n\n      if (/c/g.test(align)) {\n        expectedAlign.push(this._replaceAlignDir(align, /c(?= |$)/g, {\n          c: 'l'\n        }));\n        expectedAlign.push(this._replaceAlignDir(align, /c(?= |$)/g, {\n          c: 'r'\n        }));\n      }\n\n      expectedAlign.push(this._replaceAlignDir(align, /l|r|t|b/g, {\n        l: 'r',\n        r: 'l',\n        t: 'b',\n        b: 't'\n      }));\n    }\n\n    return expectedAlign;\n  }; // Transform align order.\n\n\n  Position.prototype._replaceAlignDir = function _replaceAlignDir(align, regExp, map) {\n    return align.replace(regExp, function (res) {\n      return map[res];\n    });\n  }; // Detecting element is in the window， we want to adjust position later.\n\n\n  Position.prototype._isInViewport = function _isInViewport(element) {\n    var viewportSize = _getViewportSize(); // Avoid animate problem that use offsetWidth instead of getBoundingClientRect.\n\n\n    var elementRect = _getElementRect(element);\n\n    return elementRect.left >= 0 && elementRect.left + element.offsetWidth <= viewportSize.width && elementRect.top >= 0 && elementRect.top + element.offsetHeight <= viewportSize.height;\n  }; // 在这里做RTL判断 top-left 定位转化为等效的 top-right定位\n\n\n  Position.prototype._setPinElementPostion = function _setPinElementPostion(pinElement, postion) {\n    var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];\n    var top = postion.top,\n        left = postion.left;\n\n    if (!this.isRtl) {\n      dom.setStyle(pinElement, {\n        left: left + offset[0] + 'px',\n        top: top + offset[1] + 'px'\n      });\n      return;\n    } // transfer {left,top} equaly to {right,top}\n\n\n    var pinElementParentOffset = this._getParentOffset(pinElement);\n\n    var _getElementRect2 = _getElementRect(pinElementParentOffset.offsetParent),\n        offsetParentWidth = _getElementRect2.width;\n\n    var _getElementRect3 = _getElementRect(pinElement),\n        width = _getElementRect3.width;\n\n    var right = offsetParentWidth - (left + width);\n    dom.setStyle(pinElement, {\n      left: 'auto',\n      right: right + offset[0] + 'px',\n      top: top + offset[1] + 'px'\n    });\n  };\n\n  return Position;\n}(), _class.VIEWPORT = VIEWPORT, _class.place = function (props) {\n  return new Position(props).setPosition();\n}, _temp);\nexport { Position as default };","map":null,"metadata":{},"sourceType":"module"}