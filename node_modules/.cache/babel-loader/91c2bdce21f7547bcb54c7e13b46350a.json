{"ast":null,"code":"import _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\n\nvar _class, _temp;\n\nimport PropTypes from 'prop-types';\nimport React, { Component } from 'react';\nimport cx from 'classnames';\nimport { findDOMNode } from 'react-dom';\nimport { events } from '../util';\n\nvar NOOP = function NOOP() {};\n\nvar MAX_SYNC_UPDATES = 100;\n\nvar isEqualSubset = function isEqualSubset(a, b) {\n  for (var key in b) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/** VirtualList */\n\n\nvar VirtualList = (_temp = _class = function (_Component) {\n  _inherits(VirtualList, _Component);\n\n  function VirtualList(props) {\n    _classCallCheck(this, VirtualList);\n\n    var _this = _possibleConstructorReturn(this, _Component.call(this, props));\n\n    var jumpIndex = props.jumpIndex;\n\n    var _this$constrain = _this.constrain(jumpIndex, 0, props),\n        from = _this$constrain.from,\n        size = _this$constrain.size;\n\n    _this.state = {\n      from: from,\n      size: size\n    };\n    _this.cache = {};\n    _this.scrollTo = _this.scrollTo.bind(_this);\n    _this.cachedScroll = null;\n    _this.unstable = false;\n    _this.updateCounter = 0;\n    return _this;\n  }\n\n  VirtualList.prototype.componentDidMount = function componentDidMount() {\n    var jumpIndex = this.props.jumpIndex;\n    this.updateFrameAndClearCache = this.updateFrameAndClearCache.bind(this);\n    events.on(window, 'resize', this.updateFrameAndClearCache);\n    this.updateFrame(this.scrollTo.bind(this, jumpIndex));\n  };\n\n  VirtualList.prototype.componentWillReceiveProps = function componentWillReceiveProps(next) {\n    var _state = this.state,\n        from = _state.from,\n        size = _state.size;\n    var oldIndex = this.props.jumpIndex;\n    var newIndex = next.jumpIndex;\n\n    if (oldIndex !== newIndex) {\n      this.updateFrame(this.scrollTo.bind(this, newIndex));\n    }\n\n    this.maybeSetState(this.constrain(from, size, next), NOOP);\n  };\n\n  VirtualList.prototype.componentDidUpdate = function componentDidUpdate() {\n    var _this2 = this; // If the list has reached an unstable state, prevent an infinite loop.\n\n\n    if (this.unstable) {\n      return;\n    }\n\n    if (++this.updateCounter > MAX_SYNC_UPDATES) {\n      this.unstable = true;\n    }\n\n    if (!this.updateCounterTimeoutId) {\n      this.updateCounterTimeoutId = setTimeout(function () {\n        _this2.updateCounter = 0;\n        delete _this2.updateCounterTimeoutId;\n      }, 0);\n    }\n\n    this.updateFrame();\n  };\n\n  VirtualList.prototype.componentWillUnmount = function componentWillUnmount() {\n    events.off(window, 'resize', this.updateFrameAndClearCache);\n    events.off(this.scrollParent, 'scroll', this.updateFrameAndClearCache);\n    events.off(this.scrollParent, 'mousewheel', NOOP);\n  };\n\n  VirtualList.prototype.maybeSetState = function maybeSetState(b, cb) {\n    if (isEqualSubset(this.state, b)) {\n      return cb();\n    }\n\n    this.setState(b, cb);\n  };\n\n  VirtualList.prototype.getOffset = function getOffset(el) {\n    var offset = el.clientLeft || 0;\n\n    do {\n      offset += el.offsetTop || 0;\n      el = el.offsetParent;\n    } while (el);\n\n    return offset;\n  };\n\n  VirtualList.prototype.getEl = function getEl() {\n    return this.el || this.items || {};\n  };\n\n  VirtualList.prototype.getScrollParent = function getScrollParent() {\n    var el = this.getEl();\n    el = el.parentElement;\n\n    switch (window.getComputedStyle(el).overflowY) {\n      case 'auto':\n      case 'scroll':\n      case 'overlay':\n      case 'visible':\n        return el;\n    }\n\n    return window;\n  };\n\n  VirtualList.prototype.getScroll = function getScroll() {\n    // Cache scroll position as this causes a forced synchronous layout.\n    // if (typeof this.cachedScroll === 'number') {\n    //     return this.cachedScroll;\n    // }\n    var scrollParent = this.scrollParent;\n    var scrollKey = 'scrollTop';\n    var actual = scrollParent === window ? // Firefox always returns document.body[scrollKey] as 0 and Chrome/Safari\n    // always return document.documentElement[scrollKey] as 0, so take\n    // whichever has a value.\n    document.body[scrollKey] || document.documentElement[scrollKey] : scrollParent[scrollKey];\n    var max = this.getScrollSize() - this.getViewportSize();\n    var scroll = Math.max(0, Math.min(actual, max));\n    var el = this.getEl();\n    this.cachedScroll = this.getOffset(scrollParent) + scroll - this.getOffset(el);\n    return this.cachedScroll;\n  };\n\n  VirtualList.prototype.setScroll = function setScroll(offset) {\n    var scrollParent = this.scrollParent;\n    offset += this.getOffset(this.getEl());\n\n    if (scrollParent === window) {\n      return window.scrollTo(0, offset);\n    }\n\n    offset -= this.getOffset(this.scrollParent);\n    scrollParent.scrollTop = offset;\n  };\n\n  VirtualList.prototype.getViewportSize = function getViewportSize() {\n    var scrollParent = this.scrollParent;\n    return scrollParent === window ? window.innerHeight : scrollParent.clientHeight;\n  };\n\n  VirtualList.prototype.getScrollSize = function getScrollSize() {\n    var scrollParent = this.scrollParent;\n    var _document = document,\n        body = _document.body,\n        documentElement = _document.documentElement;\n    var key = 'scrollHeight';\n    return scrollParent === window ? Math.max(body[key], documentElement[key]) : scrollParent[key];\n  };\n\n  VirtualList.prototype.getStartAndEnd = function getStartAndEnd() {\n    var threshold = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.threshold;\n    var scroll = this.getScroll();\n    var trueScroll = scroll;\n    var start = Math.max(0, trueScroll - threshold);\n    var end = trueScroll + this.getViewportSize() + threshold;\n    return {\n      start: start,\n      end: end\n    };\n  }; // Called by 'scroll' and 'resize' events, clears scroll position cache.\n\n\n  VirtualList.prototype.updateFrameAndClearCache = function updateFrameAndClearCache(cb) {\n    this.cachedScroll = null;\n    return this.updateFrame(cb);\n  };\n\n  VirtualList.prototype.updateFrame = function updateFrame(cb) {\n    this.updateScrollParent();\n\n    if (typeof cb !== 'function') {\n      cb = NOOP;\n    }\n\n    return this.updateVariableFrame(cb);\n  };\n\n  VirtualList.prototype.updateScrollParent = function updateScrollParent() {\n    var prev = this.scrollParent;\n    this.scrollParent = this.getScrollParent();\n\n    if (prev === this.scrollParent) {\n      return;\n    }\n\n    if (prev) {\n      events.off(prev, 'scroll', this.updateFrameAndClearCache);\n      events.off(prev, 'mousewheel', NOOP);\n    }\n\n    events.on(this.scrollParent, 'scroll', this.updateFrameAndClearCache);\n    events.on(this.scrollParent, 'mousewheel', NOOP); // You have to attach mousewheel listener to the scrollable element.\n    // Just an empty listener. After that onscroll events will be fired synchronously.\n  };\n\n  VirtualList.prototype.updateVariableFrame = function updateVariableFrame(cb) {\n    if (!this.props.itemSizeGetter) {\n      this.cacheSizes();\n    }\n\n    var _getStartAndEnd = this.getStartAndEnd(),\n        start = _getStartAndEnd.start,\n        end = _getStartAndEnd.end;\n\n    var _props = this.props,\n        pageSize = _props.pageSize,\n        children = _props.children;\n    var length = children.length;\n    var space = 0;\n    var from = 0;\n    var size = 0;\n    var maxFrom = length - 1;\n\n    while (from < maxFrom) {\n      var itemSize = this.getSizeOf(from);\n\n      if (itemSize === null || itemSize === undefined || space + itemSize > start) {\n        break;\n      }\n\n      space += itemSize;\n      ++from;\n    }\n\n    var maxSize = length - from;\n\n    while (size < maxSize && space < end) {\n      var _itemSize = this.getSizeOf(from + size);\n\n      if (_itemSize === null || _itemSize === undefined) {\n        size = Math.min(size + pageSize, maxSize);\n        break;\n      }\n\n      space += _itemSize;\n      ++size;\n    }\n\n    this.maybeSetState({\n      from: from,\n      size: size\n    }, cb);\n  };\n\n  VirtualList.prototype.getSpaceBefore = function getSpaceBefore(index) {\n    var cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!index) {\n      return 0;\n    }\n\n    if (cache[index] !== null && cache[index] !== undefined) {\n      return cache[index] || 0;\n    } // Find the closest space to index there is a cached value for.\n\n\n    var from = index;\n\n    while (from > 0 && (cache[from] === null || cache[from] === undefined)) {\n      from--;\n    } // Finally, accumulate sizes of items from - index.\n\n\n    var space = cache[from] || 0;\n\n    for (var i = from; i < index; ++i) {\n      cache[i] = space;\n      var itemSize = this.getSizeOf(i);\n\n      if (itemSize === null || itemSize === undefined) {\n        break;\n      }\n\n      space += itemSize;\n    }\n\n    cache[index] = space;\n    return cache[index] || 0;\n  };\n\n  VirtualList.prototype.cacheSizes = function cacheSizes() {\n    var cache = this.cache;\n    var from = this.state.from;\n    var _items = this.items,\n        children = _items.children,\n        _items$props = _items.props,\n        props = _items$props === undefined ? {} : _items$props;\n    var itemEls = children || props.children || [];\n\n    for (var i = 0, l = itemEls.length; i < l; ++i) {\n      var ulRef = findDOMNode(this.items);\n      var height = ulRef.children[i].offsetHeight;\n\n      if (height > 0) {\n        cache[from + i] = height;\n      }\n    }\n  };\n\n  VirtualList.prototype.getSizeOf = function getSizeOf(index) {\n    var cache = this.cache;\n    var _props2 = this.props,\n        itemSizeGetter = _props2.itemSizeGetter,\n        jumpIndex = _props2.jumpIndex; // Try the cache.\n\n    if (index in cache) {\n      return cache[index];\n    }\n\n    if (itemSizeGetter) {\n      return itemSizeGetter(index);\n    }\n\n    var height = Object.values(this.cache).pop();\n\n    if (!this.defaultItemHeight && jumpIndex > -1 && height) {\n      this.defaultItemHeight = height;\n    }\n\n    if (this.defaultItemHeight) {\n      return this.defaultItemHeight;\n    }\n  };\n\n  VirtualList.prototype.constrain = function constrain(from, size, _ref) {\n    var children = _ref.children,\n        minSize = _ref.minSize;\n    var length = children && children.length;\n    size = Math.max(size, minSize);\n\n    if (size > length) {\n      size = length;\n    }\n\n    from = from ? Math.max(Math.min(from, length - size), 0) : 0;\n    return {\n      from: from,\n      size: size\n    };\n  };\n\n  VirtualList.prototype.scrollTo = function scrollTo(index) {\n    this.setScroll(this.getSpaceBefore(index));\n  };\n\n  VirtualList.prototype.renderMenuItems = function renderMenuItems() {\n    var _this3 = this;\n\n    var _props3 = this.props,\n        children = _props3.children,\n        itemsRenderer = _props3.itemsRenderer;\n    var _state2 = this.state,\n        from = _state2.from,\n        size = _state2.size;\n    var items = [];\n\n    for (var i = 0; i < size; ++i) {\n      items.push(children[from + i]);\n    }\n\n    return itemsRenderer(items, function (c) {\n      _this3.items = c;\n      return _this3.items;\n    });\n  };\n\n  VirtualList.prototype.render = function render() {\n    var _cx,\n        _this4 = this;\n\n    var _props4 = this.props,\n        _props4$children = _props4.children,\n        children = _props4$children === undefined ? [] : _props4$children,\n        prefix = _props4.prefix,\n        className = _props4.className;\n    var length = children.length;\n    var from = this.state.from;\n    var items = this.renderMenuItems();\n    var style = {\n      position: 'relative'\n    };\n    var cache = {};\n    var size = this.getSpaceBefore(length, cache);\n\n    if (size) {\n      style.height = size;\n    }\n\n    var offset = this.getSpaceBefore(from, cache);\n    var transform = 'translate(0px, ' + offset + 'px)';\n    var listStyle = {\n      msTransform: transform,\n      WebkitTransform: transform,\n      transform: transform\n    };\n    var cls = cx((_cx = {}, _cx[prefix + 'virtual-list-wrapper'] = true, _cx[className] = !!className, _cx));\n    return React.createElement('div', {\n      className: cls,\n      style: style,\n      ref: function ref(c) {\n        _this4.el = c;\n        return _this4.el;\n      }\n    }, React.createElement('div', {\n      style: listStyle\n    }, items));\n  };\n\n  return VirtualList;\n}(Component), _class.displayName = 'VirtualList', _class.propTypes = {\n  prefix: PropTypes.string,\n\n  /**\n   * 渲染的子节点\n   */\n  children: PropTypes.any,\n\n  /**\n   * 最小加载数量\n   */\n  minSize: PropTypes.number,\n\n  /**\n   * 一屏数量\n   */\n  pageSize: PropTypes.number,\n\n  /**\n   * 父渲染函数，默认为 (items, ref) => <ul ref={ref}>{items}</ul>\n   */\n  itemsRenderer: PropTypes.func,\n\n  /**\n   * 缓冲区高度\n   */\n  threshold: PropTypes.number,\n\n  /**\n   * 获取item高度的函数\n   */\n  itemSizeGetter: PropTypes.func,\n\n  /**\n   * 设置跳转位置，需要设置 itemSizeGetter 才能生效, 不设置认为元素等高并取第一个元素高度作为默认高\n   */\n  jumpIndex: PropTypes.number,\n  className: PropTypes.string\n}, _class.defaultProps = {\n  prefix: 'next-',\n  itemsRenderer: function itemsRenderer(items, ref) {\n    return React.createElement('ul', {\n      ref: ref\n    }, items);\n  },\n  minSize: 1,\n  pageSize: 10,\n  jumpIndex: 0,\n  threshold: 100\n}, _temp);\nVirtualList.displayName = 'VirtualList';\nexport { VirtualList as default };","map":null,"metadata":{},"sourceType":"module"}